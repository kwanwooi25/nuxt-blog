const inquirer = require('inquirer');
const pkgIO = require('package-json-io');
const {promisify} = require('util');
const fs = require('fs');
const stringify = require('json-stable-stringify-without-jsonify');
const es3LintConfig = require('../es3/.eslintrc');
const es2015LintConfig = require('../es2015/.eslintrc');
const eslintToEditorConfig = require('eslint-to-editorconfig');


const ES_VERSION = {
  ES3: 3,
  ES2015: 2015,
  TS: 'TS',
};

const ES3_GUIDE = ['@kakao/styleguide/comment', '@kakao/styleguide/es3'];
const ES5_GUIDE = [...ES3_GUIDE, '@kakao/styleguide/es2015'];
const TS_GUIDE = [...ES5_GUIDE, '@kakao/styleguide/typescript'];

const GUIDE = {
  [ES_VERSION.ES3]: ES3_GUIDE,
  [ES_VERSION.ES2015]: ES5_GUIDE,
  [ES_VERSION.TS]: TS_GUIDE,
};

const makeConfig = answers => {
  const config = {env: {}, parserOptions: {}, extends: []};
  config.extends = GUIDE[answers.ecmaVersion].slice(0);
  if (answers.ecmaVersion !== ES_VERSION.TS) {
    config.parserOptions.ecmaVersion = answers.ecmaVersion;
  }
  if (answers.ecmaVersion !== ES_VERSION.ES3) {
    if (answers.modules) {
      config.parserOptions.sourceType = 'module';
    }
    config.env.es6 = true;
  }
  if (answers.commonjs) {
    config.env.commonjs = true;
  }
  answers.env.forEach(env => {
    config.env[env] = true;
  });
  return {
    config,
    configFileType: answers.configFileType,
  };
};

const asyncPkgRead = promisify(pkgIO.read);
const asyncPkgUpdate = promisify(pkgIO.update);

const LINT_SCRIPT = 'eslint --fix';

const LINT_STAGED_CONFIG = {
  'src/**/*.{js,ts}': [
    LINT_SCRIPT,
    'git add',
  ],
};
const HUSKY_CONFIG = {
  'pre-commit': 'lint-staged',
};

const githook = async () => {
  const pkg = await asyncPkgRead();

  console.log('lint-staged 설정을 추가합니다.');
  const lintStaged = pkg['lint-staged'] || {};
  for (const [match, lintStageCmd] of Object.entries(LINT_STAGED_CONFIG)) {
    let lintStageCmdList;
    if (typeof lintStageCmdList === 'string') {
      lintStageCmdList = [lintStageCmdList];
    } else {
      lintStageCmdList = lintStageCmd;
    }

    const prevList = lintStaged[match] || [];
    lintStaged[match] = [...new Set([...prevList, ...lintStageCmdList])];
  }
  pkg['lint-staged'] = lintStaged;

  console.log('husky 설정을 추가합니다.');
  const husky = pkg.husky || {};
  const huskyHooks = husky.hooks || {};
  husky.hooks = {
    ...huskyHooks,
    ...HUSKY_CONFIG,
  };
  pkg.husky = husky;

  console.log('git pre-commit hook 설정을 완료했습니다.');
  console.log('현재 설정은 ./src 하위 js 파일만 커밋 전에 검사합니다. 설정을 변경하시려면 package.json의 lint-staged 항목을 수정하세요.');

  await asyncPkgUpdate(pkg);
};

// eslint rules 설정에 맞는 .editorconfig 설정을 반환합니다.
const makeEditorConfig = (rules, sectionName) => {
  const config = eslintToEditorConfig(rules);
  return Object
    .entries(config)
    .reduce((ini, [key, value]) => `${ini}\n${key} = ${value}`, sectionName);
};

const EDITOR_CONFIG_TARGETS = ['js', 'jsx', 'ts', 'tsx'];
const EDITOR_CONFIG_FILE = '.editorconfig';
const EDITOR_CONFIG_SECTION = `[src/**.{${EDITOR_CONFIG_TARGETS.join(', ')}}]`;

// .editorconfig 파일 끝에 설정을 추가합니다. 파일이 존재하지 않는 경우 파일을 생성합니다.
const writeEditorConfig = () => {
  const es3Rules = es3LintConfig.rules || {};
  const es2015Rules = es2015LintConfig.rules || {};
  const rules = Object.assign({}, es3Rules, es2015Rules);
  const editorConfig = makeEditorConfig(rules, EDITOR_CONFIG_SECTION);

  console.log('.editorconfig 를 설정합니다.');
  if (!fs.existsSync(EDITOR_CONFIG_FILE)) {
    fs.writeFileSync(EDITOR_CONFIG_FILE, editorConfig);
  } else {
    fs.appendFileSync(EDITOR_CONFIG_FILE, editorConfig);
  }
  console.log('.editorconfig 설정을 완료 했습니다.');
  console.log(`현재 설정은 ./src 하위 파일에만 적용됩니다. 설정을 변경하시려면 ${EDITOR_CONFIG_FILE}의 ${EDITOR_CONFIG_SECTION}} 섹션을 수정하세요.`);
};

const writeConfig = ({config, configFileType}) => {
  const filePath = `./.eslintrc.${configFileType}`;
  if (fs.existsSync(filePath)) {
    const backupFile = `${filePath}_bak`;
    fs.renameSync(filePath, backupFile);
    console.log(`기존 ${filePath}을 ${backupFile}로 변경합니다.`);
  }

  console.log(`설정 파일을 쓰는중: ${filePath}`);

  let content = stringify(config, {
    cmp: (a, b) => (a.key > b.key ? 1 : -1),
    space: 2,
  });
  if (configFileType === 'js') {
    content = `module.exports = ${
      content
        .replace(/"(\w+)"\s*:/g, '$1:')
        // eslint rule(quotes)가 sinle로 설정되어 있기 때문에 (')로 교체
        .replace(/"/g, `'`)
    }\n`;
  }

  fs.writeFileSync(filePath, content, 'utf8');
  console.log(
    `성공적으로 설정 파일을 생성하였습니다. .eslintrc의 위치는 ${process.cwd()} 입니다.`
  );
};

const PROMPT_DATA = [
  {
    type: 'list',
    name: 'ecmaVersion',
    message: 'ECMAScript 몇 버전을 사용합니까?',
    choices: [
      {name: 'ES3', value: ES_VERSION.ES3},
      {name: 'ES2015+', value: ES_VERSION.ES2015},
      {name: 'TypeScript', value: ES_VERSION.TS},
    ],
    default: 1, // This is the index in the choices list
  },
  {
    type: 'confirm',
    name: 'modules',
    message: 'ES6 modules을 사용합니까?',
    default: false,
    when (answers) {
      return answers.ecmaVersion !== ES_VERSION.ES3;
    },
  },
  {
    type: 'checkbox',
    name: 'env',
    message: '이 코드는 어디서 동작 합니까?',
    default: ['browser'],
    choices: [
      {name: 'Browser', value: 'browser'},
      {name: 'Node', value: 'node'},
    ],
  },
  {
    type: 'confirm',
    name: 'commonjs',
    message: 'CommonJS를 사용합니까?',
    default: false,
    when (answers) {
      return answers.env.some(env => env === 'browser');
    },
  },
  {
    type: 'list',
    name: 'configFileType',
    message: '어떤 형태의 config file을 사용하시겠습니까?',
    choices: [
      {name: '.eslintrc.json', value: 'json'},
      {name: '.eslintrc.js', value: 'js'},
    ],
  },
  {
    type: 'confirm',
    name: 'precommit',
    message:
      'git pre-commit hook을 설정 하시겠습니까?\n(이 동작은 husky, lint-staged 패키지를 설치하고 package.json에 설정을 추가합니다)',
    default: true,
  },
  {
    type: 'confirm',
    name: 'editorconfig',
    message: '.editorconfig를 설정 하시겠습니까?\n(이동작은 .editorconfig 에 스타일 가이드 관련 설정을 추가합니다)',
    default: false,
  },
];

const init = async () => {
  const answer = await inquirer.prompt(PROMPT_DATA);

  const config = makeConfig(answer);
  writeConfig(config);

  const {precommit, editorconfig} = answer;
  if (precommit) {
    await githook();
  }
  if (editorconfig) {
    writeEditorConfig();
  }
};

module.exports = {
  init,
};
