# ES3 Style Guide

이 문서는 ECMAScript 3 로 작성된 코드에 권장되는 코딩 스타일을 안내합니다.

다른 스타일 가이드
- [JSDoc 주석](../comment)
- [ES2015+](../es2015)

참고한 사이트
- [Airbnb JavaScript StyleGuide](https://github.com/airbnb/javascript)
- [ESLint 홈페이지](https://eslint.org/)

이 문서의 규칙들은 ESLint 에서 제시한 다음 기준으로 구분됩니다.  

- Variables: 변수 선언 및 정의와 관련된 규칙들
- Stylistic Issues: 가독성을 높이고 협업자 모두가 동일한 스타일을 유지하기 위한 규칙들 
- Possible Errors: 문법 또는 논리적 문제를 방지하는 규칙들  
- Best Practices: 문제를 피하는 더 좋은 방법을 제안하는 규칙들

각각의 분류 안에서는 Airbnb JavaScript StyleGuide 에서 제시한 분류 기준으로 모아서, 다음 순서대로 나열합니다.

1. Types
1. Type casting & coercion
1. Variables
1. Naming conventions
1. Whitespace
1. Blocks
1. Commas
1. Semicolons
1. Objects
1. Properties
1. Functions
1. Arrow Functions
1. Strings
1. Arrays
1. RegExp
1. Classes & Constructors
1. Iterators & Generators
1. Control statements
1. Comparison Operators & Equality
1. Destructuring
1. Modules
1. Errors
1. Comments
1. Etc

---

## Table of Contents

- **1. Variables**
  - [1.1. 변수에 delete 연산자를 사용하지 않는다.](#no-delete-var)
  - [1.2. 네임스페이스를 사용하여 전역변수를 최소화한다.](#no-undef)
  - [1.3. undefined 로 초기화하지 않는다.](#no-undef-init)
  - [1.4. 사용하지 않는 변수를 정의하지 않는다.](#no-unused-vars)
  - [1.5. 예약어를 이름으로 쓰지 않는다.](#no-shadow-restricted-names)
- **2. Stylistic Issues**
  - [2.1. 변수 할당 체이닝을 하지 않는다.](#no-multi-assign)
  - [2.2. 변수별 var 선언을 하고, 선언과 동시에 할당하는 것을 원칙으로 한다.](#one-var)
  - [2.3. 여러 줄의 연산자를 사용할 경우 줄의 끝에 연산자를 쓴다.](#operator-linebreak)
  - [2.4. 변수나 함수 이름 사용 시 카멜케이스(camelcase)를 사용한다.](#camelcase)
  - [2.5. 생성자 이름은 대문자로 시작한다.](#new-cap)
  - [2.6. 한 줄에 중괄호로 처리할 경우 공백을 추가한다.](#block-spacing)
  - [2.7. 쉼표 뒤에 공백을 둔다.](#comma-spacing)
  - [2.8. 파일의 끝에는 개행문자를 둔다.](#eol-last)
  - [2.9. 함수 식별자와 호출 사이에는 공백이 없어야 한다.](#func-call-spacing)
  - [2.10. 들여쓰기는 space 2문자(2칸 들여쓰기)를 사용한다.](#indent)
  - [2.11. 키와 값을 구분하는 콜론(:) 다음에 공백을 추가한다.](#key-spacing)
  - [2.12. 예약어 뒤에는 공백을 추가한다.](#keyword-spacing)
  - [2.13. word-wrap은 120자로 유지한다.](#max-len)
  - [2.14. 3줄 이상의 공백을 사용하지 않는다.](#no-multiple-empty-lines)
  - [2.15. 탭 문자를 사용하지 않는다.](#no-tabs)
  - [2.16. 줄 끝에서 공백을 사용하지 않는다.](#no-trailing-spaces)
  - [2.17. 속성 앞에 공백이 없어야 한다.](#no-whitespace-before-property)
  - [2.18. 중괄호 안쪽에는 공백을 두지 않는다.](#object-curly-spacing)
  - [2.19. 세미콜론은 뒤쪽에 공백을 둔다.](#semi-spacing)
  - [2.20. 블록 앞에 공백을 추가한다.](#space-before-blocks)
  - [2.21. 함수 선언 괄호 앞에 공백을 추가한다.](#space-before-function-paren)
  - [2.22. 괄호 안에 공백을 사용하지 않는다.](#space-in-parens)
  - [2.23. 연산자와 다른 코드(피연산자) 사이에는 공백을 둔다.](#space-infix-ops)
  - [2.24. 단항 연산자가 문자일 때는 연산자와 피연산자 사이에 공백을 두고, 기호일 때는 공백을 두지 않는다.](#space-unary-ops)
  - [2.25. 주석 안에는 공백을 사용한다.](#spaced-comment)
  - [2.26. 블록의 여는 중괄호를 새로운 줄에 쓰지 않는다.](#brace-style)
  - [2.27. 여러 줄의 블록에 중괄호를 사용한다.](#nonblock-statement-body-position)
  - [2.28. 블록 안에 불필요한 줄 바꿈을 하지 않는다.](#padded-blocks)
  - [2.29. 외톨이 콤마(마지막 속성 뒤의 쉼표)는 사용하지 않는다.](#comma-dangle)
  - [2.30. 쉼표는 행의 끝에 둔다.](#comma-style)
  - [2.31. 인수가 없는 생성자는 괄호로 호출한다.](#new-parens)
  - [2.32. Object 생성자를 사용하지 않는다.](#no-new-object)
  - [2.33. 객체 속성 표현의 일관성을 유지한다.](#object-property-newline)
  - [2.34. 객체 리터럴 속성에 싱글 쿼테이션(&#x27;)이나 더블 쿼테이션(&quot;)을 사용하지 않는다.](#quote-props)
  - [2.35. 문자열은 싱글 쿼테이션(&#x27;)를 사용한다.](#quotes)
  - [2.36. 유니코드 BOM(Byte Order Mark)을 사용하지 않는다.](#unicode-bom)
  - [2.37. 배열 리터럴을 사용한다.](#no-array-constructor)
  - [2.38. 연산자를 섞어 사용할 때 같은 연산자들을 괄호로 감싼다.](#no-mixed-operators)
  - [2.39. 더 간단한 대안이 있을 때 삼항연산자를 사용하지 않는다.](#no-unneeded-ternary)
  - [2.40. 여러 줄의 주석은 /* */ 을 사용하고, 첫 줄과 마지막 줄은 사용하지 않는다.](#multiline-comment-style)
  - [2.41. 문장의 종료에는 세미콜론(;)을 사용한다.](#semi)
- **3. Possible Errors**
  - [3.1. 불필요한 boolean 캐스트를 피한다.](#no-extra-boolean-cast)
  - [3.2. 불규칙한 공백문자가 없어야 한다.](#no-irregular-whitespace)
  - [3.3. 객체 리터럴에서 중복된 키 값을 사용하지 않는다](#no-dupe-keys)
  - [3.4. Object 의 빌트인 함수는 Object.prototype 을 통해서만 사용한다.](#no-prototype-builtins)
  - [3.5. 함수 정의시 중복된 인수를 사용하지 않는다.](#no-dupe-args)
  - [3.6. 중괄호 안에서 함수 선언문을 사용하지 않는다.](#no-inner-declarations)
  - [3.7. 전역 객체를 함수로 호출하지 않는다.](#no-obj-calls)
  - [3.8. 빈 공간 배열은 사용하지 않는다.](#no-sparse-arrays)
  - [3.9. 정규표현식에는 제어문자를 사용하지 않는다.](#no-control-regex)
  - [3.10. 정규표현식에서 빈 문자셋을 사용하지 않는다.](#no-empty-character-class)
  - [3.11. RegExp 생성자에 잘못된 정규 표현식 문자열이 없어야 한다.](#no-invalid-regexp)
  - [3.12. 정규표현식 리터럴에서는 공백을 피한다.](#no-regex-spaces)
  - [3.13. 상수를 조건문에 사용하지 않는다.](#no-constant-condition)
  - [3.14. switch문에서 중복된 case 사용하지 않는다.](#no-duplicate-case)
  - [3.15. return, throw, continue, break 문 다음 실행 코드는 작성하지 않는다.](#no-unreachable)
  - [3.16. -0 과 비교하지 않는다.](#no-compare-neg-zero)
  - [3.17. 모호한 부정문은 괄호를 사용해서 모호하지 않게 한다.](#no-unsafe-negation)
  - [3.18. NaN 과 비교할 때는 isNaN() 을 사용한다.](#use-isnan)
  - [3.19. typeof 연산자 결과는 문자열과 비교한다.](#valid-typeof)
  - [3.20. catch 절의 예외를 재할당하지 않는다.](#no-ex-assign)
  - [3.21. finally에는 흐름을 제어할 수 있는 명령문이 없어야 한다.](#no-unsafe-finally)
  - [3.22. debugger를 사용하지 않는다.](#no-debugger)
  - [3.23. 불필요한 괄호를 사용하지 않는다.](#no-extra-parens)
- **4. Best Practices**
  - [4.1. 소수점 앞/뒤의 0을 생략하지 않는다.](#no-floating-decimal)
  - [4.2. 8진수를 사용하지 않는다.](#no-octal)
  - [4.3. 문자열 리터럴에는 8진수 이스케이프 시퀀스를 사용하지 않는다.](#no-octal-escape)
  - [4.4. 원시 래퍼 인스턴스를 사용하지 않는다.](#no-new-wrappers)
  - [4.5. 변수를 중복해서 정의하지 않는다.](#no-redeclare)
  - [4.6. 변수에 자기 자신은 할당하지 않는다.](#no-self-assign)
  - [4.7. 읽기 전용 전역 변수를 재정의하지 않는다.](#no-global-assign)
  - [4.8. 들여쓰기를 제외하고는 공백을 연달아 사용하지 않는다.](#no-multi-spaces)
  - [4.9. 불필요하게 블록을 중첩하지 않는다.](#no-lone-blocks)
  - [4.10. 쉼표 연산자를 사용하지 않는다.](#no-sequences)
  - [4.11. 네이티브 객체를 확장하지 않는다.](#no-extend-native)
  - [4.12. 변수에 객체를 대입하지 않고 new 연산자를 사용하지 않는다.](#no-new)
  - [4.13. \_\_proto\_\_ 를 사용하지 않는다.](#no-proto)
  - [4.14. 멤버연산자 점(dot)은 각 속성과 같은 줄에 위치한다.](#dot-location)
  - [4.15. 함수 프로퍼티 접근은 멤버연산자 점(dot)을 사용한다.](#dot-notation)
  - [4.16. arguments.callee와 arguments.caller를 사용하지 않는다.](#no-caller)
  - [4.17. 불필요한 함수 바인딩을 피한다.](#no-extra-bind)
  - [4.18. 선언된 함수를 덮어쓰지 않는다.](#no-func-assign)
  - [4.19. Function 생성자를 사용하지 않는다.](#no-new-func)
  - [4.20. 함수의 파라미터를 재할당하지 않는다.](#no-param-reassign)
  - [4.21. 할당문을 반환하지 않는다.](#no-return-assign)
  - [4.22. 불필요한 call(), apply() 를 사용하지 않는다.](#no-useless-call)
  - [4.23. 불필요한 return 문을 사용하지 않는다.](#no-useless-return)
  - [4.24. 즉시 호출 함수 표현식(IIFE)은 괄호로 감싼다.](#wrap-iife)
  - [4.25. 멀티라인 문자열을 사용하지 않는다.](#no-multi-str)
  - [4.26. 불필요한 이스케이프는 사용하지 않는다.](#no-useless-escape)
  - [4.27. 암묵적으로 default case 를 생략하지 않는다.](#default-case)
  - [4.28. 조건부 안에서 할당할 때 추가로 괄호로 묶는다.](#no-cond-assign)
  - [4.29. case 문이 비어있지 않으면 암묵적으로 종료문을 생략하지 않는다.](#no-fallthrough)
  - [4.30. 무한 반복되는 반복문을 사용하지 않는다.](#no-unmodified-loop-condition)
  - [4.31. &#x3D;&#x3D;와 !&#x3D; 대신 &#x3D;&#x3D;&#x3D;와 !&#x3D;&#x3D;를 사용한다.](#eqeqeq)
  - [4.32. 변수를 자기 자신과 비교하지 않는다.](#no-self-compare)
  - [4.33. 비교문은 변수를 좌변에 둔다.](#yoda)
  - [4.34. 에러 객체는 항상 처리한다.](#handle-callback-err)
  - [4.35. 반드시 throw는 Error 객체를 사용한다.](#no-throw-literal)
  - [4.36. eval()을 사용하지 않는다.](#no-eval)
  - [4.37. 문자열을 코드로 실행하지 않는다.](#no-implied-eval)
  - [4.38. 라벨문을 사용하지 않는다.](#no-labels)
  - [4.39. 의미를 바로 알 수 없는 상수의 사용을 지양한다.](#no-magic-numbers)
  - [4.40. 의미 없는 표현식을 사용하지 않는다.](#no-unused-expressions)
  - [4.41. with문을 사용하지 않는다.](#no-with)

---

## 1. Variables

<a name="no-delete-var"></a><a name="1.1"></a>
- [1.1](#no-delete-var). 변수에 delete 연산자를 사용하지 않는다.
  > ESLint: [no-delete-var](https://eslint.org/docs/rules/no-delete-var)  

  ```js
  // ✗ bad
  var x;
  delete x;
  ```

<a name="no-undef"></a><a name="1.2"></a>
- [1.2](#no-undef). 네임스페이스를 사용하여 전역변수를 최소화한다.
  
  암묵적인 전역변수는 사용하지 않는다.
불가피하게 전역변수를 사용해야 한다면  /* global ...*/ 주석을 파일 상단에 기재한다.  
  
  > ESLint: [no-undef](https://eslint.org/docs/rules/no-undef)  

  ```js
  // ✗ bad
  var a = someFunction();
  b = 10;
  ```
  
  ```js
  // ✓ good
  /* global someFunction b:true */

  var a = someFunction();
  b = 10;
  ```

<a name="no-undef-init"></a><a name="1.3"></a>
- [1.3](#no-undef-init). undefined 로 초기화하지 않는다.
  
  빈 값으로 초기화할 경우 null 을 사용한다.  
  
  > ESLint: [no-undef-init](https://eslint.org/docs/rules/no-undef-init)  

  ```js
  // ✗ bad
  var foo = undefined;
  ```
  
  ```js
  // ✓ good
  var foo;
  var bar = null;
  ```

<a name="no-unused-vars"></a><a name="1.4"></a>
- [1.4](#no-unused-vars). 사용하지 않는 변수를 정의하지 않는다.
  > ESLint: [no-unused-vars](https://eslint.org/docs/rules/no-unused-vars)  

  ```js
  // ✗ bad
  someUnusedVar = 42;

  var x;

  // 사용되지 않는 초기값
  var y = 10;
  y = 5;

  var z = 0;
  z = z + 1;

  // 사용하지 않는 매개변수
  (function (foo) {
    return 5;
  })();

  // 다른 곳에서 호출되지 않는 재귀함수
  function fact (n) {
    if (n < 2) return 1;
    return n * fact(n - 1);
  }
  ```

<a name="no-shadow-restricted-names"></a><a name="1.5"></a>
- [1.5](#no-shadow-restricted-names). 예약어를 이름으로 쓰지 않는다.
  > ESLint: [no-shadow-restricted-names](https://eslint.org/docs/rules/no-shadow-restricted-names)  

  ```js
  // ✗ bad
  function NaN () {}

  var undefined;
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 2. Stylistic Issues

<a name="no-multi-assign"></a><a name="2.1"></a>
- [2.1](#no-multi-assign). 변수 할당 체이닝을 하지 않는다.
  > ESLint: [no-multi-assign](https://eslint.org/docs/rules/no-multi-assign)  

  ```js
  // ✗ bad
  var a = b = c = 5;

  var foo = bar = 'baz';
  ```
  
  ```js
  // ✓ good
  var a = 5;
  var b = 5;
  var c = 5;

  var foo = 'baz';
  var bar = 'baz';

  var a = c;
  var b = c;
  ```

<a name="one-var"></a><a name="2.2"></a>
- [2.2](#one-var). 변수별 var 선언을 하고, 선언과 동시에 할당하는 것을 원칙으로 한다.
  > ESLint: [one-var](https://eslint.org/docs/rules/one-var)  

  ```js
  // ✗ bad
  var silent = true, verbose = true;

  var silent = true,
    verbose = true;
  ```
  
  ```js
  // ✓ good
  var silent = true;
  var verbose = true;
  ```

<a name="operator-linebreak"></a><a name="2.3"></a>
- [2.3](#operator-linebreak). 여러 줄의 연산자를 사용할 경우 줄의 끝에 연산자를 쓴다.
  
  단, 삼항연산자는 줄의 시작에 연산자를 둔다.  
  
  > ESLint: [operator-linebreak](https://eslint.org/docs/rules/operator-linebreak)  

  ```js
  // ✗ bad
  foo = 1
    +
    2;

  foo = 1
    + 2;

  foo
    = 5;

  if (someCondition
    || otherCondition) {
  }

  answer = everything ?
    42 :
    foo;
  ```
  
  ```js
  // ✓ good
  foo = 1 + 2;

  foo = 1 +
    2;

  foo =
    5;

  if (someCondition ||
    otherCondition) {
  }

  answer = everything
    ? 42
    : foo;
  ```

<a name="camelcase"></a><a name="2.4"></a>
- [2.4](#camelcase). 변수나 함수 이름 사용 시 카멜케이스(camelcase)를 사용한다.
  > ESLint: [camelcase](https://eslint.org/docs/rules/camelcase)  

  ```js
  // ✗ bad
  var my_favorite_color = '#112C85';

  function do_something () {
    // ...
  }

  obj.do_something = function () {
    // ...
  };

  function foo ({isCamelcased: no_camelcased}) {
    // ...
  }

  var obj = {
    my_pref: 1
  };
  ```
  
  ```js
  // ✓ good
  var myFavoriteColor = '#112C85';
  var _myFavoriteColor = '#112C85';
  var myFavoriteColor_ = '#112C85';
  var MY_FAVORITE_COLOR = '#112C85';
  var foo = bar.baz_boom;
  var foo = {qux: bar.baz_boom};

  obj.do_something(); // 외부에서 정의한 객체일 수 있기 때문에 선언이 아닌 사용은 가능
  do_something();
  var foo = new SomeClass();

  function foo ({isCamelCased: isAlsoCamelCased}) {
    // ...
  }
  ```

<a name="new-cap"></a><a name="2.5"></a>
- [2.5](#new-cap). 생성자 이름은 대문자로 시작한다.
  
  외부 라이브러리 사용 중 해당 규칙과 충돌하는 경우 충돌하는 이름을 변경하여 사용합니다.  
  - import {Map as map} from &#x27;immutable&#x27;; 
  - const {Map: map} &#x3D; require(&#x27;immutable&#x27;);
  - var map &#x3D; Immutable.Map;
  
  
  > ESLint: [new-cap](https://eslint.org/docs/rules/new-cap)  

  ```js
  // ✗ bad
  var friend = new person();

  var colleague = Person();
  ```
  
  ```js
  // ✓ good
  var colleague = new Person();
  ```

<a name="block-spacing"></a><a name="2.6"></a>
- [2.6](#block-spacing). 한 줄에 중괄호로 처리할 경우 공백을 추가한다.
  > ESLint: [block-spacing](https://eslint.org/docs/rules/block-spacing)  

  ```js
  // ✗ bad
  function foo () {return true;}
  if (foo) { bar = 0;}
  ```
  
  ```js
  // ✓ good
  function foo () { return true; }
  if (foo) { bar = 0; }
  ```

<a name="comma-spacing"></a><a name="2.7"></a>
- [2.7](#comma-spacing). 쉼표 뒤에 공백을 둔다.
  > ESLint: [comma-spacing](https://eslint.org/docs/rules/comma-spacing)  

  ```js
  // ✗ bad
  var arr = [1 , 2];
  var obj = {foo: 'bar' ,baz: 'qur'};
  foo(a ,b);
  var foo = new Foo(a ,b);
  function foo (a ,b) {}
  ```
  
  ```js
  // ✓ good
  var arr = [1, 2];
  var obj = {foo: 'bar', baz: 'qur'};
  foo(a, b);
  var foo = new Foo(a, b);
  function foo (a, b) {}
  ```

<a name="eol-last"></a><a name="2.8"></a>
- [2.8](#eol-last). 파일의 끝에는 개행문자를 둔다.
  > ESLint: [eol-last](https://eslint.org/docs/rules/eol-last)  

  ```js
  // ✗ bad
  function doSmth () {
    var foo = 2;
  }
  ```
  
  ```js
  // ✓ good
  function doSmth () {
    var foo = 2;
  }\n
  ```

<a name="func-call-spacing"></a><a name="2.9"></a>
- [2.9](#func-call-spacing). 함수 식별자와 호출 사이에는 공백이 없어야 한다.
  > ESLint: [func-call-spacing](https://eslint.org/docs/rules/func-call-spacing)  

  ```js
  // ✗ bad
  fn ();

  fn
  ();
  ```
  
  ```js
  // ✓ good
  fn();
  ```

<a name="indent"></a><a name="2.10"></a>
- [2.10](#indent). 들여쓰기는 space 2문자(2칸 들여쓰기)를 사용한다.
  > ESLint: [indent](https://eslint.org/docs/rules/indent)  

  ```js
  // ✗ bad
  switch (a) {
      case 'a':
          break;
      case 'b':
          break;
  }

  (function () {
  function foo (x) {
    return x + 1;
  }
  })();

  foo
  .bar
  .baz();

  foo(bar,
    baz,
      qux
  );

  var foo = [
    bar,
  baz,
    qux
  ];

  if (foo) {
    doSomething();

  // comment intentionally de-indented
    doSomethingElse();
  }
  ```
  
  ```js
  // ✓ good
  switch (a) {
    case 'a':
      break;
    case 'b':
      break;
  }

  (function () {
    function foo (x) {
      return x + 1;
    }
  })();

  foo
    .bar
    .baz();

  foo(bar,
    baz,
    qux
  );

  var foo = [
    bar,
    baz,
    qux
  ];

  if (foo) {
    doSomething();

    // comment intentionally de-indented
    doSomethingElse();
  }
  ```

<a name="key-spacing"></a><a name="2.11"></a>
- [2.11](#key-spacing). 키와 값을 구분하는 콜론(:) 다음에 공백을 추가한다.
  > ESLint: [key-spacing](https://eslint.org/docs/rules/key-spacing)  

  ```js
  // ✗ bad
  var obj = {foo:42};

  var obj = {foo : 42};

  var obj = {foo :42};
  ```
  
  ```js
  // ✓ good
  var obj = {foo: 42};
  ```

<a name="keyword-spacing"></a><a name="2.12"></a>
- [2.12](#keyword-spacing). 예약어 뒤에는 공백을 추가한다.
  > ESLint: [keyword-spacing](https://eslint.org/docs/rules/keyword-spacing)  

  ```js
  // ✗ bad
  if (foo) {
    // ...
  }else if (bar) {
    // ...
  }else {
    // ...
  }

  if(foo) {
    // ...
  } else if(bar) {
    // ...
  } else{
    // ...
  }
  ```
  
  ```js
  // ✓ good
  if (foo) {
    // ...
  } else if (bar) {
    // ...
  } else {
    // ...
  }
  ```

<a name="max-len"></a><a name="2.13"></a>
- [2.13](#max-len). word-wrap은 120자로 유지한다.
  
  단, 아래 항목들은 길이 제한에서 제외한다.
  - 주석
  - 한 줄의 끝에 붙이는 주석
  - URL
  - 문자열
  - 정규표현식  
  
  > ESLint: [max-len](https://eslint.org/docs/rules/max-len)  

  ```js
  // ✗ bad
  var foo = {bar: 'This is a bar.', baz: {qux: 'This is a qux'}, difficult: 'to read', str1: 'something long', str2: 'long 2'};
  ```
  
  ```js
  // ✓ good
  var foo = {
    bar: 'This is a bar.',
    baz: {qux: 'This is a qux'},
    difficult: 'to read',
    str1: 'something long',
    str2: 'long 2'
  };
  ```

<a name="no-multiple-empty-lines"></a><a name="2.14"></a>
- [2.14](#no-multiple-empty-lines). 3줄 이상의 공백을 사용하지 않는다.
  > ESLint: [no-multiple-empty-lines](https://eslint.org/docs/rules/no-multiple-empty-lines)  

  ```js
  // ✗ bad
  var foo = 5;



  var bar = 3;
  ```
  
  ```js
  // ✓ good
  var foo = 5;


  var bar = 3;
  ```

<a name="no-tabs"></a><a name="2.15"></a>
- [2.15](#no-tabs). 탭 문자를 사용하지 않는다.
  > ESLint: [no-tabs](https://eslint.org/docs/rules/no-tabs)  

  ```js
  // ✗ bad
  var a 	= 2;
  
  /**
   * 		 it's a test function
   */
  function test () {}
  
  var x = 1; // 	 test
  ```
  
  ```js
  // ✓ good
  var a = 2;

  /**
   * it's a test function
   */
  function test () {}

  var x = 1; // test
  ```

<a name="no-trailing-spaces"></a><a name="2.16"></a>
- [2.16](#no-trailing-spaces). 줄 끝에서 공백을 사용하지 않는다.
  > ESLint: [no-trailing-spaces](https://eslint.org/docs/rules/no-trailing-spaces)  

  ```js
  // ✗ bad
  var foo = 0;// •••••
  var baz = 5;// ••
  // •••••
  ```
  
  ```js
  // ✓ good
  var foo = 0;
  var baz = 5;
  ```

<a name="no-whitespace-before-property"></a><a name="2.17"></a>
- [2.17](#no-whitespace-before-property). 속성 앞에 공백이 없어야 한다.
  > ESLint: [no-whitespace-before-property](https://eslint.org/docs/rules/no-whitespace-before-property)  

  ```js
  // ✗ bad
  foo [bar];

  foo. bar;

  foo .bar;

  foo. bar. baz;

  foo. bar()
    .baz();

  foo
    .bar(). baz();
  ```
  
  ```js
  // ✓ good
  foo[bar];

  foo.bar.baz;

  foo
    .bar()
    .baz();
  ```

<a name="object-curly-spacing"></a><a name="2.18"></a>
- [2.18](#object-curly-spacing). 중괄호 안쪽에는 공백을 두지 않는다.
  > ESLint: [object-curly-spacing](https://eslint.org/docs/rules/object-curly-spacing)  

  ```js
  // ✗ bad
  var obj = { foo: 'bar' };
  var obj = {foo: 'bar' };
  var obj = { baz: {foo: 'qux'}, bar};
  var obj = {baz: { foo: 'qux' }, bar};
  var obj = {foo: 'bar'
  };
  var obj = {
    foo: 'bar'};
  ```
  
  ```js
  // ✓ good
  var obj = {};
  var obj = {foo: 'bar'};
  var obj = {foo: {bar: 'baz'}, qux: 'quxx'};
  var obj = {
    foo: 'bar'
  };
  ```

<a name="semi-spacing"></a><a name="2.19"></a>
- [2.19](#semi-spacing). 세미콜론은 뒤쪽에 공백을 둔다.
  > ESLint: [semi-spacing](https://eslint.org/docs/rules/semi-spacing)  

  ```js
  // ✗ bad
  var foo ;

  throw new Error('error') ;

  while (a) { break ; }

  for (i = 0 ; i < 10 ; i++) {}

  for (i = 0;i < 10;i++) {}
  ```
  
  ```js
  // ✓ good
  var foo;

  throw new Error('error');

  while (a) { break; }

  for (i = 0; i < 10; i++) {}

  for (;;) {}

  if (foo) { ; }
  ```

<a name="space-before-blocks"></a><a name="2.20"></a>
- [2.20](#space-before-blocks). 블록 앞에 공백을 추가한다.
  > ESLint: [space-before-blocks](https://eslint.org/docs/rules/space-before-blocks)  

  ```js
  // ✗ bad
  function f (a){
    b();
  }

  function a (){}

  for (;;){
    b();
  }

  try {} catch (a){}

  class Foo{
    constructor (){}
  }
  ```
  
  ```js
  // ✓ good
  if (a) {
    b();
  }

  if (a) {
    b();
  } else { /* no error. this is checked by `keyword-spacing` rule. */
    c();
  }


  function a () {}

  for (;;) {
    b();
  }

  try {} catch (a) {}
  ```

<a name="space-before-function-paren"></a><a name="2.21"></a>
- [2.21](#space-before-function-paren). 함수 선언 괄호 앞에 공백을 추가한다.
  > ESLint: [space-before-function-paren](https://eslint.org/docs/rules/space-before-function-paren)  

  ```js
  // ✗ bad
  var f = function() {};

  var g = function () {};

  var h = function() {};

  var y = function functionNme() {};
  ```
  
  ```js
  // ✓ good
  var x = function () {};

  var y = function functionNme () {};
  ```

<a name="space-in-parens"></a><a name="2.22"></a>
- [2.22](#space-in-parens). 괄호 안에 공백을 사용하지 않는다.
  > ESLint: [space-in-parens](https://eslint.org/docs/rules/space-in-parens)  

  ```js
  // ✗ bad
  foo( 'bar');
  foo('bar' );
  foo( 'bar' );

  var foo = ( 1 + 2 ) * 3;

  ( function () { return 'bar'; }() );
  ```
  
  ```js
  // ✓ good
  foo();

  foo('bar');

  var foo = (1 + 2) * 3;

  (function () { return 'bar'; }());
  ```

<a name="space-infix-ops"></a><a name="2.23"></a>
- [2.23](#space-infix-ops). 연산자와 다른 코드(피연산자) 사이에는 공백을 둔다.
  > ESLint: [space-infix-ops](https://eslint.org/docs/rules/space-infix-ops)  

  ```js
  // ✗ bad
  a+b;

  a+ b;

  a +b;

  a?b:c;

  var a={b: 1};

  function foo (a=0) {}
  ```
  
  ```js
  // ✓ good
  a + b;

  a ? b : c;

  var a = {b: 1};

  function foo (a = 0) {}
  ```

<a name="space-unary-ops"></a><a name="2.24"></a>
- [2.24](#space-unary-ops). 단항 연산자가 문자일 때는 연산자와 피연산자 사이에 공백을 두고, 기호일 때는 공백을 두지 않는다.
  > ESLint: [space-unary-ops](https://eslint.org/docs/rules/space-unary-ops)  

  ```js
  // ✗ bad
  typeof!foo;

  void{foo: 0};

  var bar = new[foo][0]();

  delete(foo.bar);

  ++ foo;

  foo --;

  - foo;

  + '3';
  ```
  
  ```js
  // ✓ good
  delete foo.bar;

  var bar = new Foo();

  void 0;

  ++foo;

  foo--;

  -foo;

  +'3';
  ```

<a name="spaced-comment"></a><a name="2.25"></a>
- [2.25](#spaced-comment). 주석 안에는 공백을 사용한다.
  > ESLint: [spaced-comment](https://eslint.org/docs/rules/spaced-comment)  

  ```js
  // ✗ bad
  //This is a comment with no whitespace at the beginning

  /*This is a comment with no whitespace at the beginning */

  /**
   *make() returns a new element
   *based on the passed-in tag name
   */
  ```
  
  ```js
  // ✓ good
  // This is a comment with a whitespace at the beginning

  /* This is a comment with a whitespace at the beginning */

  /*
   * This is a comment with a whitespace at the beginning
   */

  /**
   * make() returns a new element
   * based on the passed-in tag name
   */
  ```

<a name="brace-style"></a><a name="2.26"></a>
- [2.26](#brace-style). 블록의 여는 중괄호를 새로운 줄에 쓰지 않는다.
  > ESLint: [brace-style](https://eslint.org/docs/rules/brace-style)  

  ```js
  // ✗ bad
  function foo ()
  {
    return true;
  }

  if (foo)
  {
    bar();
  }

  try
  {
    somethingRisky();
  } catch (e)
  {
    handleError();
  }

  if (foo) {
    bar();
  }
  else {
    baz();
  }
  ```
  
  ```js
  // ✓ good
  function nop () { }

  if (foo) { bar(); }

  if (foo) { bar(); } else { baz(); }

  try { somethingRisky(); } catch (e) { handleError(); }
  ```

<a name="nonblock-statement-body-position"></a><a name="2.27"></a>
- [2.27](#nonblock-statement-body-position). 여러 줄의 블록에 중괄호를 사용한다.
  > ESLint: [nonblock-statement-body-position](https://eslint.org/docs/rules/nonblock-statement-body-position)  

  ```js
  // ✗ bad
  if (test)
    return false;

  function foo () { return false; }
  ```
  
  ```js
  // ✓ good
  if (test) return false;

  if (test) {
    return false;
  }

  function bar () {
    return false;
  }
  ```

<a name="padded-blocks"></a><a name="2.28"></a>
- [2.28](#padded-blocks). 블록 안에 불필요한 줄 바꿈을 하지 않는다.
  > ESLint: [padded-blocks](https://eslint.org/docs/rules/padded-blocks)  

  ```js
  // ✗ bad
  function f (a) {

    b();

  }

  if (a) {

    b();

  }

  if (a) {

    b();
  }

  if (a) {
    b();

  }
  ```
  
  ```js
  // ✓ good
  if (a) {
    b();
  }
  ```

<a name="comma-dangle"></a><a name="2.29"></a>
- [2.29](#comma-dangle). 외톨이 콤마(마지막 속성 뒤의 쉼표)는 사용하지 않는다.
  > ESLint: [comma-dangle](https://eslint.org/docs/rules/comma-dangle)  

  ```js
  // ✗ bad
  var foo = {
    bar: 'baz',
    qux: 'quux',
  };

  var bar = [
    1,
    2,
    3,
  ];

  var foo = [1, 2, 3, ];
  ```
  
  ```js
  // ✓ good
  var foo = {
    bar: 'baz',
    qux: 'quux'
  };

  var bar = [
    1,
    2,
    3
  ];

  var foo = [1, 2, 3];
  ```

<a name="comma-style"></a><a name="2.30"></a>
- [2.30](#comma-style). 쉼표는 행의 끝에 둔다.
  > ESLint: [comma-style](https://eslint.org/docs/rules/comma-style)  

  ```js
  // ✗ bad
  var foo = ['apples'
    , 'oranges'];

  function bar () {
    return {
      a: 1
      , 'b:': 2
    };
  }
  ```
  
  ```js
  // ✓ good
  var foo = ['apples',
    'oranges'];

  function bar () {
    return {
      a: 1,
      'b:': 2
    };
  }
  ```

<a name="new-parens"></a><a name="2.31"></a>
- [2.31](#new-parens). 인수가 없는 생성자는 괄호로 호출한다.
  > ESLint: [new-parens](https://eslint.org/docs/rules/new-parens)  

  ```js
  // ✗ bad
  var person = new Person;
  var person = new (Person);
  ```
  
  ```js
  // ✓ good
  var person = new Person();
  ```

<a name="no-new-object"></a><a name="2.32"></a>
- [2.32](#no-new-object). Object 생성자를 사용하지 않는다.
  > ESLint: [no-new-object](https://eslint.org/docs/rules/no-new-object)  

  ```js
  // ✗ bad
  var myObject = new Object();

  var myObject = new Object();
  ```
  
  ```js
  // ✓ good
  var myObject = new CustomObject();

  var myObject = {};
  ```

<a name="object-property-newline"></a><a name="2.33"></a>
- [2.33](#object-property-newline). 객체 속성 표현의 일관성을 유지한다.
  > ESLint: [object-property-newline](https://eslint.org/docs/rules/object-property-newline)  

  ```js
  // ✗ bad
  var user = {
    name: 'Jane Doe', age: 30,
    username: 'jdoe86'
  };
  ```
  
  ```js
  // ✓ good
  var user = {name: 'Jane Doe', age: 30, username: 'jdoe86'};

  var user = {
    name: 'Jane Doe',
    age: 30,
    username: 'jdoe86'
  };
  ```

<a name="quote-props"></a><a name="2.34"></a>
- [2.34](#quote-props). 객체 리터럴 속성에 싱글 쿼테이션(&#x27;)이나 더블 쿼테이션(&quot;)을 사용하지 않는다.
  
  단, 키에 대쉬(-)나 공백 등이 포함될 경우에는 싱글 쿼테이션을 사용한다.  
  
  > ESLint: [quote-props](https://eslint.org/docs/rules/quote-props)  

  ```js
  // ✗ bad
  const bad = {
    'foo': 3,
    "bar": 4,
    "data-blah": 5
  };
  ```
  
  ```js
  // ✓ good
  const good = {
    foo: 3,
    bar: 4,
    'data-blah': 5,
    'my-name': 5
  };
  ```

<a name="quotes"></a><a name="2.35"></a>
- [2.35](#quotes). 문자열은 싱글 쿼테이션(&#x27;)를 사용한다.
  
  단, 문자열 안에 싱글 쿼테이션이 포함된 경우에는 더블 쿼테이션(&quot;)을 사용한다.  
  
  > ESLint: [quotes](https://eslint.org/docs/rules/quotes)  

  ```js
  // ✗ bad
  var string = "some string";

  var single = 'a string containing \'single\' quotes';
  ```
  
  ```js
  // ✓ good
  var string = 'some string';

  var single = 'a string containing "double" quotes';

  var double = "a string containing 'single' quotes";
  ```

<a name="unicode-bom"></a><a name="2.36"></a>
- [2.36](#unicode-bom). 유니코드 BOM(Byte Order Mark)을 사용하지 않는다.
  
  유니코드 BOM(Byte Order Mark)은 코드 단위가 빅 endian인지 또는 little endian인지 지정하는 데 사용됩니다.  
  
  > ESLint: [unicode-bom](https://eslint.org/docs/rules/unicode-bom)  
  > 이유: UTF-8은 BOM 을 필요로하지 않습니다.  
  ```js
  // ✗ bad
  U+FEFF;
  var abc;
  ```

<a name="no-array-constructor"></a><a name="2.37"></a>
- [2.37](#no-array-constructor). 배열 리터럴을 사용한다.
  > ESLint: [no-array-constructor](https://eslint.org/docs/rules/no-array-constructor)  

  ```js
  // ✗ bad
  var arr = Array(0, 1, 2);

  var arr = new Array(0, 1, 2);
  ```
  
  ```js
  // ✓ good
  var arr = [];

  // 특정 길이의 배열을 만들 때만 사용
  var arr = new Array(lengthOfArray);
  ```

<a name="no-mixed-operators"></a><a name="2.38"></a>
- [2.38](#no-mixed-operators). 연산자를 섞어 사용할 때 같은 연산자들을 괄호로 감싼다.
  
  단, 다음 목록에서 같은 줄에 있는 연산자들은 섞어서 사용해도 괄호로 묶지 않는다.
  - &#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;
  - &amp;&amp;, ||
  - in, instanceof  
  
  > ESLint: [no-mixed-operators](https://eslint.org/docs/rules/no-mixed-operators)  

  ```js
  // ✗ bad
  var foo = a && b < 0 || c > 0 || d + 1 === 0;
  var foo = a + b * c;
  ```
  
  ```js
  // ✓ good
  var foo = a || b || c;
  var foo = a && b && c;
  var foo = (a && b < 0) || c > 0 || d + 1 === 0;
  var foo = a && (b < 0 || c > 0 || d + 1 === 0);
  var foo = a + (b * c);
  var foo = (a + b) * c;
  ```

<a name="no-unneeded-ternary"></a><a name="2.39"></a>
- [2.39](#no-unneeded-ternary). 더 간단한 대안이 있을 때 삼항연산자를 사용하지 않는다.
  > ESLint: [no-unneeded-ternary](https://eslint.org/docs/rules/no-unneeded-ternary)  

  ```js
  // ✗ bad
  var a = x === 2 ? true : false;

  var a = x ? true : false;

  var a = f(x ? x : 1);

  var a = x ? x : 1;
  ```
  
  ```js
  // ✓ good
  var a = x === 2 ? 'Yes' : 'No';

  var a = x !== false;

  var a = x ? 'Yes' : 'No';

  var a = x ? y : x;

  var a = x || 1;
  ```

<a name="multiline-comment-style"></a><a name="2.40"></a>
- [2.40](#multiline-comment-style). 여러 줄의 주석은 /* */ 을 사용하고, 첫 줄과 마지막 줄은 사용하지 않는다.
  > ESLint: [multiline-comment-style](https://eslint.org/docs/rules/multiline-comment-style)  

  ```js
  // ✗ bad
  // this line
  // calls foo()
  foo();

  /* this line
  calls foo() */
  foo();

  /* this comment
   * is missing a newline after /*
   */

  /*
   * this comment
   * is missing a newline at the end */

  /*
  * the star in this line should have a space before it
   */

  /*
   * the star on the following line should have a space before it
  */
  ```
  
  ```js
  // ✓ good
  /*
   * this line
   * calls foo()
   */
  foo();

  // single-line comment
  ```

<a name="semi"></a><a name="2.41"></a>
- [2.41](#semi). 문장의 종료에는 세미콜론(;)을 사용한다.
  > ESLint: [semi](https://eslint.org/docs/rules/semi)  

  ```js
  // ✗ bad
  var name = 'ESLint'

  object.method = function () {
    // ...
  }
  ```
  
  ```js
  // ✓ good
  var name = 'ESLint';

  object.method = function () {
    // ...
  };
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 3. Possible Errors

<a name="no-extra-boolean-cast"></a><a name="3.1"></a>
- [3.1](#no-extra-boolean-cast). 불필요한 boolean 캐스트를 피한다.
  > ESLint: [no-extra-boolean-cast](https://eslint.org/docs/rules/no-extra-boolean-cast)  

  ```js
  // ✗ bad
  var foo = !!!bar;

  var foo = !!bar ? baz : bat;

  var foo = Boolean(!!bar);

  if (!!foo) {
    // ...
  }

  if (Boolean(foo)) {
    // ...
  }

  while (!!foo) {
    // ...
  }

  do {
    // ...
  } while (Boolean(foo));

  for (; !!foo;) {
    // ...
  }
  ```
  
  ```js
  // ✓ good
  var foo = !!bar;
  var foo = Boolean(bar);

  function foo () {
    return !!bar;
  }

  var foo = bar ? !!baz : !!bat;
  ```

<a name="no-irregular-whitespace"></a><a name="3.2"></a>
- [3.2](#no-irregular-whitespace). 불규칙한 공백문자가 없어야 한다.
  
  space, tab 문자 외에 다른 공백문자를 사용하지 않는다.  
이 규칙에서 허용하지 않는 공백문자는 다음과 같다.  
  - \u000B - Line Tabulation (\v) - &lt;VT&gt;
  - \u000C - Form Feed (\f) - &lt;FF&gt;
  - \u00A0 - No-Break Space - &lt;NBSP&gt;
  - \u0085 - Next Line
  - \u1680 - Ogham Space Mark
  - \u180E - Mongolian Vowel Separator - &lt;MVS&gt;
  - \ufeff - Zero Width No-Break Space - &lt;BOM&gt;
  - \u2000 - En Quad
  - \u2001 - Em Quad
  - \u2002 - En Space - &lt;ENSP&gt;
  - \u2003 - Em Space - &lt;EMSP&gt;
  - \u2004 - Tree-Per-Em
  - \u2005 - Four-Per-Em
  - \u2006 - Six-Per-Em
  - \u2007 - Figure Space
  - \u2008 - Punctuation Space - &lt;PUNCSP&gt;
  - \u2009 - Thin Space
  - \u200A - Hair Space
  - \u200B - Zero Width Space - &lt;ZWSP&gt;
  - \u2028 - Line Separator
  - \u2029 - Paragraph Separator
  - \u202F - Narrow No-Break Space
  - \u205f - Medium Mathematical Space
  - \u3000 - Ideographic Space
  
  
  > ESLint: [no-irregular-whitespace](https://eslint.org/docs/rules/no-irregular-whitespace)  


<a name="no-dupe-keys"></a><a name="3.3"></a>
- [3.3](#no-dupe-keys). 객체 리터럴에서 중복된 키 값을 사용하지 않는다
  > ESLint: [no-dupe-keys](https://eslint.org/docs/rules/no-dupe-keys)  

  ```js
  // ✗ bad
  var foo = {
    bar: 'baz',
    bar: 'qux'
  };

  var foo = {
    bar: 'baz',
    bar: 'qux'
  };

  var foo = {
    0x1: 'baz',
    1: 'qux'
  };
  ```
  
  ```js
  // ✓ good
  var foo = {
    bar: 'baz',
    quxx: 'qux'
  };
  ```

<a name="no-prototype-builtins"></a><a name="3.4"></a>
- [3.4](#no-prototype-builtins). Object 의 빌트인 함수는 Object.prototype 을 통해서만 사용한다.
  > ESLint: [no-prototype-builtins](https://eslint.org/docs/rules/no-prototype-builtins)  

  ```js
  // ✗ bad
  var hasBarProperty = foo.hasOwnProperty('bar');

  var isPrototypeOfBar = foo.isPrototypeOf(bar);

  var barIsEnumerable = foo.propertyIsEnumerable('bar');
  ```
  
  ```js
  // ✓ good
  var hasBarProperty = Object.prototype.hasOwnProperty.call(foo, 'bar');

  var isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar);

  var barIsEnumerable = Object.prototype.propertyIsEnumerable.call(foo, 'bar');
  ```

<a name="no-dupe-args"></a><a name="3.5"></a>
- [3.5](#no-dupe-args). 함수 정의시 중복된 인수를 사용하지 않는다.
  > ESLint: [no-dupe-args](https://eslint.org/docs/rules/no-dupe-args)  

  ```js
  // ✗ bad
  function foo (a, b, a) {
    console.log('value of the second a:', a);
  }

  var bar = function (a, b, a) {
    console.log('value of the second a:', a);
  };
  ```
  
  ```js
  // ✓ good
  function foo (a, b, c) {
    console.log(a, b, c);
  }

  var bar = function (a, b, c) {
    console.log(a, b, c);
  };
  ```

<a name="no-inner-declarations"></a><a name="3.6"></a>
- [3.6](#no-inner-declarations). 중괄호 안에서 함수 선언문을 사용하지 않는다.
  > ESLint: [no-inner-declarations](https://eslint.org/docs/rules/no-inner-declarations)  

  ```js
  // ✗ bad
  if (test) {
    function doSomething () { }
  }

  function doSomethingElse () {
    if (test) {
      function doAnotherThing () { }
    }
  }
  ```
  
  ```js
  // ✓ good
  function doSomething () { }

  function doSomethingElse () {
    function doAnotherThing () { }
  }

  if (test) {
    asyncCall(id, function (err, data) { });
  }

  var fn;
  if (test) {
    fn = function fnExpression () { };
  }
  ```

<a name="no-obj-calls"></a><a name="3.7"></a>
- [3.7](#no-obj-calls). 전역 객체를 함수로 호출하지 않는다.
  > ESLint: [no-obj-calls](https://eslint.org/docs/rules/no-obj-calls)  

  ```js
  // ✗ bad
  var math = Math();
  var json = JSON();
  ```

<a name="no-sparse-arrays"></a><a name="3.8"></a>
- [3.8](#no-sparse-arrays). 빈 공간 배열은 사용하지 않는다.
  > ESLint: [no-sparse-arrays](https://eslint.org/docs/rules/no-sparse-arrays)  

  ```js
  // ✗ bad
  var items = [, ];
  var colors = ['red', , 'blue'];
  ```
  
  ```js
  // ✓ good
  var colors = ['red', 'blue'];
  var items = new Array(23);
  ```

<a name="no-control-regex"></a><a name="3.9"></a>
- [3.9](#no-control-regex). 정규표현식에는 제어문자를 사용하지 않는다.
  
  제어문자는 ASCII 코드 0 ~ 31에 해당하는 문자이다.  
  
  > ESLint: [no-control-regex](https://eslint.org/docs/rules/no-control-regex)  
  > 이유: 보이지 않는 문자이므로 예기치 않은 오류를 발생시킬 수 있다.  
  ```js
  // ✗ bad
  var pattern1 = /\x1f/;

  var pattern2 = new RegExp('\x1f');
  ```

<a name="no-empty-character-class"></a><a name="3.10"></a>
- [3.10](#no-empty-character-class). 정규표현식에서 빈 문자셋을 사용하지 않는다.
  > ESLint: [no-empty-character-class](https://eslint.org/docs/rules/no-empty-character-class)  

  ```js
  // ✗ bad
  /^abc[]/.test('abcdefg'); // false
  'abcdefg'.match(/^abc[]/); // null
  ```
  
  ```js
  // ✓ good
  /^abc/.test('abcdefg'); // true
  'abcdefg'.match(/^abc/); // ["abc"]

  /^abc[a-z]/.test('abcdefg'); // true
  'abcdefg'.match(/^abc[a-z]/); // ["abcd"]
  ```

<a name="no-invalid-regexp"></a><a name="3.11"></a>
- [3.11](#no-invalid-regexp). RegExp 생성자에 잘못된 정규 표현식 문자열이 없어야 한다.
  > ESLint: [no-invalid-regexp](https://eslint.org/docs/rules/no-invalid-regexp)  

  ```js
  // ✗ bad
  var reg = new RegExp('.', 'z');

  var reg = new RegExp('\\');
  ```

<a name="no-regex-spaces"></a><a name="3.12"></a>
- [3.12](#no-regex-spaces). 정규표현식 리터럴에서는 공백을 피한다.
  > ESLint: [no-regex-spaces](https://eslint.org/docs/rules/no-regex-spaces)  

  ```js
  // ✗ bad
  var re = /foo   bar/;
  var re = new RegExp('foo   bar');
  ```
  
  ```js
  // ✓ good
  var re = /foo {3}bar/;
  var re = new RegExp('foo {3}bar');
  ```

<a name="no-constant-condition"></a><a name="3.13"></a>
- [3.13](#no-constant-condition). 상수를 조건문에 사용하지 않는다.
  
  단, 반복문 안에서 조건에 따른 종료가 명시돼 있으면 사용 가능하다.  
  
  > ESLint: [no-constant-condition](https://eslint.org/docs/rules/no-constant-condition)  

  ```js
  // ✗ bad
  if (false) {
    doSomethingUnfinished();
  }

  if (void x) {
    doSomethingUnfinished();
  }

  for (;-2;) {
    doSomethingForever();
  }

  while (typeof x) {
    doSomethingForever();
  }

  do {
    doSomethingForever();
  } while (x = -1);

  var result = 0 ? a : b;
  ```
  
  ```js
  // ✓ good
  if (foo) {
    doSomethingUnfinished();
  }

  do {
    doSomethingForever();
  } while (x === -1);

  while (true) {
    doSomething();
    if (condition()) {
      break;
    }
  }

  for (; true;) {
    doSomething();
    if (condition()) {
      break;
    }
  }

  do {
    doSomething();
    if (condition()) {
      break;
    }
  } while (true);
  ```

<a name="no-duplicate-case"></a><a name="3.14"></a>
- [3.14](#no-duplicate-case). switch문에서 중복된 case 사용하지 않는다.
  > ESLint: [no-duplicate-case](https://eslint.org/docs/rules/no-duplicate-case)  

  ```js
  // ✗ bad
  var a = 1;
  var one = 1;

  switch (a) {
    case 1:
      break;
    case 2:
      break;
    case 1: // duplicate test expression
      break;
    default:
      break;
  }

  switch (a) {
    case one:
      break;
    case 2:
      break;
    case one: // duplicate test expression
      break;
    default:
      break;
  }

  switch (a) {
    case '1':
      break;
    case '2':
      break;
    case '1': // duplicate test expression
      break;
    default:
      break;
  }
  ```
  
  ```js
  // ✓ good
  var a = 1;
  var one = 1;

  switch (a) {
    case 1:
      break;
    case 2:
      break;
    case 3:
      break;
    default:
      break;
  }

  switch (a) {
    case one:
      break;
    case 2:
      break;
    case 3:
      break;
    default:
      break;
  }

  switch (a) {
    case '1':
      break;
    case '2':
      break;
    case '3':
      break;
    default:
      break;
  }
  ```

<a name="no-unreachable"></a><a name="3.15"></a>
- [3.15](#no-unreachable). return, throw, continue, break 문 다음 실행 코드는 작성하지 않는다.
  > ESLint: [no-unreachable](https://eslint.org/docs/rules/no-unreachable)  

  ```js
  // ✗ bad
  function foo () {
    return true;
    console.log('done');
  }

  function bar () {
    throw new Error('Oops!');
    console.log('done');
  }

  while (value) {
    break;
    console.log('done');
  }

  throw new Error('Oops!');
  console.log('done');

  function baz () {
    if (Math.random() < 0.5) {
      return;
    } else {
      throw new Error();
    }
    console.log('done');
  }

  for (;;) {}
  console.log('done');
  ```

<a name="no-compare-neg-zero"></a><a name="3.16"></a>
- [3.16](#no-compare-neg-zero). -0 과 비교하지 않는다.
  > ESLint: [no-compare-neg-zero](https://eslint.org/docs/rules/no-compare-neg-zero)  

  ```js
  // ✗ bad
  if (x === -0) {
    // doSomething()...
  }
  ```
  
  ```js
  // ✓ good
  if (x === 0) {
    // doSomething()...
  }

  if (Object.is(x, -0)) {
    // doSomething()...
  }
  ```

<a name="no-unsafe-negation"></a><a name="3.17"></a>
- [3.17](#no-unsafe-negation). 모호한 부정문은 괄호를 사용해서 모호하지 않게 한다.
  > ESLint: [no-unsafe-negation](https://eslint.org/docs/rules/no-unsafe-negation)  

  ```js
  // ✗ bad
  if (!key in object) {
    /*
     * 다음 두 가지로 해석 가능
     * (!key) in object
     * !(key in object)
     */
  }

  if (!obj instanceof Ctor) {
    /*
     * 다음 두 가지로 해석 가능
     * (!obj) instanceof Ctor
     * !(obj instanceof Ctor)
     */
  }
  ```
  
  ```js
  // ✓ good
  if (!(key in object)) {
    // key 가 object 의 프로퍼티가 아닐 때
  }

  if (!(obj instanceof Ctor)) {
    // obj 가 Ctor 의 인스턴스가 아닐 때
  }
  ```

<a name="use-isnan"></a><a name="3.18"></a>
- [3.18](#use-isnan). NaN 과 비교할 때는 isNaN() 을 사용한다.
  > ESLint: [use-isnan](https://eslint.org/docs/rules/use-isnan)  

  ```js
  // ✗ bad
  if (foo == NaN) {
    // ...
  }

  if (foo != NaN) {
    // ...
  }

  if (foo === NaN) {
    // ...
  }

  if (foo !== NaN) {
    // ...
  }
  ```
  
  ```js
  // ✓ good
  if (isNaN(foo)) {
    // ...
  }

  if (!isNaN(foo)) {
    // ...
  }
  ```

<a name="valid-typeof"></a><a name="3.19"></a>
- [3.19](#valid-typeof). typeof 연산자 결과는 문자열과 비교한다.
  
  typeof 연산자의 결과도 문자열이므로 typeof 연산자 결과끼리의 비교도 가능하다.  
  
  > ESLint: [valid-typeof](https://eslint.org/docs/rules/valid-typeof)  

  ```js
  // ✗ bad
  typeof foo === undefined;
  typeof bar === Object;
  typeof baz === 'strnig';
  typeof qux === 'some invalid type';
  typeof baz === anotherVariable;
  typeof foo === 5;
  ```
  
  ```js
  // ✓ good
  typeof foo === 'undefined';
  typeof bar === 'object';
  typeof baz === 'string';
  typeof bar === typeof qux;
  ```

<a name="no-ex-assign"></a><a name="3.20"></a>
- [3.20](#no-ex-assign). catch 절의 예외를 재할당하지 않는다.
  > ESLint: [no-ex-assign](https://eslint.org/docs/rules/no-ex-assign)  

  ```js
  // ✗ bad
  try {
    // code
  } catch (e) {
    e = 10;
  }
  ```
  
  ```js
  // ✓ good
  try {
    // code
  } catch (e) {
    var foo = 10;
  }
  ```

<a name="no-unsafe-finally"></a><a name="3.21"></a>
- [3.21](#no-unsafe-finally). finally에는 흐름을 제어할 수 있는 명령문이 없어야 한다.
  > ESLint: [no-unsafe-finally](https://eslint.org/docs/rules/no-unsafe-finally)  
  > 이유: finally 의 제어문이 try / catch 절의 제어문을 덮어쓰게 된다.  
  ```js
  // ✗ bad
  var foo = function () {
    try {
      return 1;
    } catch (err) {
      return 2;
    } finally {
      return 3;
    }
  };
  ```
  
  ```js
  // ✓ good
  var foo = function () {
    try {
      return 1;
    } catch (err) {
      return 2;
    } finally {
      console.log('hola!');
    }
  };
  ```

<a name="no-debugger"></a><a name="3.22"></a>
- [3.22](#no-debugger). debugger를 사용하지 않는다.
  
  로컬에서의 디버깅을 위해 process.env.USE_LOCAL_LINT_RULE&#x3D;&quot;true&quot; 로 지정된 경우에는 error가 아닌 warning으로 취급합니다.  
  
  > ESLint: [no-debugger](https://eslint.org/docs/rules/no-debugger)  
  > 이유: 개발자의 실수로 코드에 남아있을 경우 어플리케이션의 동작을 멈출 수 있다.  
  ```js
  // ✗ bad
  function isTruthy (x) {
    debugger;
    return Boolean(x);
  }
  ```
  
  ```js
  // ✓ good
  function isTruthy (x) {
    return Boolean(x); // set a breakpoint at this line
  }
  ```

<a name="no-extra-parens"></a><a name="3.23"></a>
- [3.23](#no-extra-parens). 불필요한 괄호를 사용하지 않는다.
  > ESLint: [no-extra-parens](https://eslint.org/docs/rules/no-extra-parens)  

  ```js
  // ✗ bad
  ((function foo () {}))();

  var y = (function () { return 1; });
  ```
  
  ```js
  // ✓ good
  var y = function () { return 1; };
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 4. Best Practices

<a name="no-floating-decimal"></a><a name="4.1"></a>
- [4.1](#no-floating-decimal). 소수점 앞/뒤의 0을 생략하지 않는다.
  > ESLint: [no-floating-decimal](https://eslint.org/docs/rules/no-floating-decimal)  

  ```js
  // ✗ bad
  var num = .5;
  var num = 2.;
  var num = -.7;
  ```
  
  ```js
  // ✓ good
  var num = 0.5;
  var num = 2.0;
  var num = -0.7;
  ```

<a name="no-octal"></a><a name="4.2"></a>
- [4.2](#no-octal). 8진수를 사용하지 않는다.
  > ESLint: [no-octal](https://eslint.org/docs/rules/no-octal)  
  > 이유: 8진수 사용시 8 이상의 숫자가 포함돼 있으면 10진수로 인식하는 등 혼란이 있을 수 있다.  
  ```js
  // ✗ bad
  var num = 071; // 57
  var result = 085 + 071; // 85 + 57 => 142
  ```

<a name="no-octal-escape"></a><a name="4.3"></a>
- [4.3](#no-octal-escape). 문자열 리터럴에는 8진수 이스케이프 시퀀스를 사용하지 않는다.
  > ESLint: [no-octal-escape](https://eslint.org/docs/rules/no-octal-escape)  
  > 이유: ECMAScript 5 사양에서 문자열 리터럴의 8 진수 이스케이프 시퀀스는 사용되지 않는다. 대신 유니 코드 이스케이프 시퀀스를 사용해야한다.  
  ```js
  // ✗ bad
  var foo = 'Copyright \251';
  ```
  
  ```js
  // ✓ good
  var foo = 'Copyright \u00A9'; // unicode

  var foo = 'Copyright \xA9'; // hexadecimal
  ```

<a name="no-new-wrappers"></a><a name="4.4"></a>
- [4.4](#no-new-wrappers). 원시 래퍼 인스턴스를 사용하지 않는다.
  > ESLint: [no-new-wrappers](https://eslint.org/docs/rules/no-new-wrappers)  
  > 이유: typeof new String(&quot;str&quot;) 의 결과는 string 이 아니라 object 이다. 이와 같은 혼란을 피할 수 있다.  
  ```js
  // ✗ bad
  var stringObject = new String('Hello world');
  var numberObject = new Number(33);
  var booleanObject = new Boolean(false);

  var stringObject = new String();
  var numberObject = new Number();
  var booleanObject = new Boolean();
  ```
  
  ```js
  // ✓ good
  var text = 'some string';
  var num = 1;
  var boolean = false;
  ```

<a name="no-redeclare"></a><a name="4.5"></a>
- [4.5](#no-redeclare). 변수를 중복해서 정의하지 않는다.
  > ESLint: [no-redeclare](https://eslint.org/docs/rules/no-redeclare)  

  ```js
  // ✗ bad
  var a = 3;
  var a = 10;
  ```
  
  ```js
  // ✓ good
  var a = 3;
  // ...
  a = 10;
  ```

<a name="no-self-assign"></a><a name="4.6"></a>
- [4.6](#no-self-assign). 변수에 자기 자신은 할당하지 않는다.
  > ESLint: [no-self-assign](https://eslint.org/docs/rules/no-self-assign)  

  ```js
  // ✗ bad
  foo = foo;

  obj.a = obj.a;
  ```

<a name="no-global-assign"></a><a name="4.7"></a>
- [4.7](#no-global-assign). 읽기 전용 전역 변수를 재정의하지 않는다.
  > ESLint: [no-global-assign](https://eslint.org/docs/rules/no-global-assign)  

  ```js
  // ✗ bad
  Object = null;
  undefined = 1;
  ```

<a name="no-multi-spaces"></a><a name="4.8"></a>
- [4.8](#no-multi-spaces). 들여쓰기를 제외하고는 공백을 연달아 사용하지 않는다.
  > ESLint: [no-multi-spaces](https://eslint.org/docs/rules/no-multi-spaces)  

  ```js
  // ✗ bad
  var a =  1;

  if (foo   === 'bar') {}

  a <<  b;

  var arr = [1,  2];

  a ?  b : c;
  ```
  
  ```js
  // ✓ good
  var a = 1;

  if (foo === 'bar') {}

  a << b;

  var arr = [1, 2];

  a ? b : c;
  ```

<a name="no-lone-blocks"></a><a name="4.9"></a>
- [4.9](#no-lone-blocks). 불필요하게 블록을 중첩하지 않는다.
  > ESLint: [no-lone-blocks](https://eslint.org/docs/rules/no-lone-blocks)  

  ```js
  // ✗ bad
  {}

  if (foo) {
    bar();
    {
      baz();
    }
  }

  function bar () {
    {
      baz();
    }
  }
  ```
  
  ```js
  // ✓ good
  while (foo) {
    bar();
  }

  if (foo) {
    if (bar) {
      baz();
    }
  }

  function bar () {
    baz();
  }
  ```

<a name="no-sequences"></a><a name="4.10"></a>
- [4.10](#no-sequences). 쉼표 연산자를 사용하지 않는다.
  > ESLint: [no-sequences](https://eslint.org/docs/rules/no-sequences)  

  ```js
  // ✗ bad
  foo = doSomething(), val;

  do {} while (doSomething(), !!test);

  for (; doSomething(), !!test;);

  if (doSomething(), !!test);

  switch (val = foo(), val) {}

  while (val = foo(), val < 42);
  ```

<a name="no-extend-native"></a><a name="4.11"></a>
- [4.11](#no-extend-native). 네이티브 객체를 확장하지 않는다.
  > ESLint: [no-extend-native](https://eslint.org/docs/rules/no-extend-native)  

  ```js
  // ✗ bad
  Object.prototype.extra = 55;

  var users = {
    123: 'Stan',
    456: 'David'
  };

  for (var id in users) {
    console.log(id); // "123", "456", "extra"
  }
  ```

<a name="no-new"></a><a name="4.12"></a>
- [4.12](#no-new). 변수에 객체를 대입하지 않고 new 연산자를 사용하지 않는다.
  > ESLint: [no-new](https://eslint.org/docs/rules/no-new)  

  ```js
  // ✗ bad
  new Thing();
  ```
  
  ```js
  // ✓ good
  var thing = new Thing();

  var foo = (new Thing()).someMethod();
  ```

<a name="no-proto"></a><a name="4.13"></a>
- [4.13](#no-proto). \_\_proto\_\_ 를 사용하지 않는다.
  > ESLint: [no-proto](https://eslint.org/docs/rules/no-proto)  

  ```js
  // ✗ bad
  var a = obj.__proto__;

  var a = obj.__proto__;
  ```
  
  ```js
  // ✓ good
  var a = Object.getPrototypeOf(obj);
  ```

<a name="dot-location"></a><a name="4.14"></a>
- [4.14](#dot-location). 멤버연산자 점(dot)은 각 속성과 같은 줄에 위치한다.
  > ESLint: [dot-location](https://eslint.org/docs/rules/dot-location)  

  ```js
  // ✗ bad
  var foo = object.
    property;
  ```
  
  ```js
  // ✓ good
  var foo = object
    .property;

  var bar = object.property;
  ```

<a name="dot-notation"></a><a name="4.15"></a>
- [4.15](#dot-notation). 함수 프로퍼티 접근은 멤버연산자 점(dot)을 사용한다.
  > ESLint: [dot-notation](https://eslint.org/docs/rules/dot-notation)  

  ```js
  // ✗ bad
  var x = foo['bar'];
  ```
  
  ```js
  // ✓ good
  var x = foo.bar;

  var x = foo[bar]; // 변수의 값을 속성명으로 사용할 때
  ```

<a name="no-caller"></a><a name="4.16"></a>
- [4.16](#no-caller). arguments.callee와 arguments.caller를 사용하지 않는다.
  > ESLint: [no-caller](https://eslint.org/docs/rules/no-caller)  

  ```js
  // ✗ bad
  function foo (n) {
    if (n <= 0) {
      return;
    }

    arguments.callee(n - 1);
  }

  [1, 2, 3, 4, 5].map(function (n) {
    return !(n > 1) ? 1 : arguments.callee(n - 1) * n;
  });

  function bar () {
    console.log(arguments.caller);
  }
  ```
  
  ```js
  // ✓ good
  function foo (n) {
    if (n <= 0) {
      return;
    }

    foo(n - 1);
  }

  [1, 2, 3, 4, 5].map(function factorial (n) {
    return !(n > 1) ? 1 : factorial(n - 1) * n;
  });
  ```

<a name="no-extra-bind"></a><a name="4.17"></a>
- [4.17](#no-extra-bind). 불필요한 함수 바인딩을 피한다.
  > ESLint: [no-extra-bind](https://eslint.org/docs/rules/no-extra-bind)  

  ```js
  // ✗ bad
  var x = function () {
    foo();
  }.bind(bar);

  var x = function () {
    (function () {
      this.foo();
    }());
  }.bind(bar);

  var x = function () {
    function foo () {
      this.bar();
    }
  }.bind(baz);
  ```
  
  ```js
  // ✓ good
  var x = function () {
    this.foo();
  }.bind(bar);

  var x = function (a) {
    return a + 1;
  }.bind(foo, bar);
  ```

<a name="no-func-assign"></a><a name="4.18"></a>
- [4.18](#no-func-assign). 선언된 함수를 덮어쓰지 않는다.
  > ESLint: [no-func-assign](https://eslint.org/docs/rules/no-func-assign)  

  ```js
  // ✗ bad
  function foo () {}
  foo = bar;

  function foo () {
    foo = bar;
  }
  ```
  
  ```js
  // ✓ good
  var foo = function () {};
  foo = bar;

  function foo () {
    var foo = bar;
  }
  ```

<a name="no-new-func"></a><a name="4.19"></a>
- [4.19](#no-new-func). Function 생성자를 사용하지 않는다.
  > ESLint: [no-new-func](https://eslint.org/docs/rules/no-new-func)  

  ```js
  // ✗ bad
  var x = new Function('a', 'b', 'return a + b');

  var x = Function('a', 'b', 'return a + b');
  ```
  
  ```js
  // ✓ good
  var x = function (a, b) {
    return a + b;
  };
  ```

<a name="no-param-reassign"></a><a name="4.20"></a>
- [4.20](#no-param-reassign). 함수의 파라미터를 재할당하지 않는다.
  > ESLint: [no-param-reassign](https://eslint.org/docs/rules/no-param-reassign)  

  ```js
  // ✗ bad
  function foo (bar) {
    bar = 13;
  }

  function foo (bar) {
    bar += 2;
  }
  ```
  
  ```js
  // ✓ good
  function foo (bar) {
    var baz = bar;
    baz += 2;
  }
  ```

<a name="no-return-assign"></a><a name="4.21"></a>
- [4.21](#no-return-assign). 할당문을 반환하지 않는다.
  > ESLint: [no-return-assign](https://eslint.org/docs/rules/no-return-assign)  

  ```js
  // ✗ bad
  function doSomething () {
    return foo = bar + 2;
  }

  function doSomething () {
    return foo += 2;
  }
  ```
  
  ```js
  // ✓ good
  function doSomething () {
    return foo === bar + 2;
  }

  function doSomething () {
    return (foo = bar + 2);
  }
  ```

<a name="no-useless-call"></a><a name="4.22"></a>
- [4.22](#no-useless-call). 불필요한 call(), apply() 를 사용하지 않는다.
  > ESLint: [no-useless-call](https://eslint.org/docs/rules/no-useless-call)  

  ```js
  // ✗ bad
  foo.call(undefined, 1, 2, 3);
  foo.apply(undefined, [1, 2, 3]);
  foo.call(null, 1, 2, 3);
  foo.apply(null, [1, 2, 3]);

  obj.foo.call(obj, 1, 2, 3);
  obj.foo.apply(obj, [1, 2, 3]);
  ```
  
  ```js
  // ✓ good
  // this 바인딩이 달라짐
  foo.call(obj, 1, 2, 3);
  foo.apply(obj, [1, 2, 3]);
  obj.foo.call(null, 1, 2, 3);
  obj.foo.apply(null, [1, 2, 3]);
  obj.foo.call(otherObj, 1, 2, 3);
  obj.foo.apply(otherObj, [1, 2, 3]);

  // 매개변수를 배열로 전달할 때
  foo.apply(undefined, args);
  foo.apply(null, args);
  obj.foo.apply(obj, args);
  ```

<a name="no-useless-return"></a><a name="4.23"></a>
- [4.23](#no-useless-return). 불필요한 return 문을 사용하지 않는다.
  > ESLint: [no-useless-return](https://eslint.org/docs/rules/no-useless-return)  

  ```js
  // ✗ bad
  function foo () { }

  function foo () {
    doSomething();
  }

  function foo () {
    if (condition) {
      bar();
    } else {
      baz();
    }
  }

  function foo () {
    switch (bar) {
      case 1:
        doSomething();
        break;

      default:
        doSomethingElse();
        return;
    }
  }
  ```
  
  ```js
  // ✓ good
  function foo () { return 5; }

  function foo () {
    return doSomething();
  }

  function foo () {
    if (condition) {
      bar();
      return;
    } else {
      baz();
    }
    qux();
  }

  function foo () {
    switch (bar) {
      case 1:
        doSomething();
        return;
      default:
        doSomethingElse();
    }
  }

  function foo () {
    for (const foo of bar) {
      return;
    }
  }
  ```

<a name="wrap-iife"></a><a name="4.24"></a>
- [4.24](#wrap-iife). 즉시 호출 함수 표현식(IIFE)은 괄호로 감싼다.
  > ESLint: [wrap-iife](https://eslint.org/docs/rules/wrap-iife)  

  ```js
  // ✗ bad
  var getName = function () { }();
  ```
  
  ```js
  // ✓ good
  var getName = (function () { }());

  var getName = (function () { })();
  ```

<a name="no-multi-str"></a><a name="4.25"></a>
- [4.25](#no-multi-str). 멀티라인 문자열을 사용하지 않는다.
  > ESLint: [no-multi-str](https://eslint.org/docs/rules/no-multi-str)  

  ```js
  // ✗ bad
  var x = 'Line 1 \
         Line 2';
  ```
  
  ```js
  // ✓ good
  var x = 'Line 1\n' +
    'Line 2';
  ```

<a name="no-useless-escape"></a><a name="4.26"></a>
- [4.26](#no-useless-escape). 불필요한 이스케이프는 사용하지 않는다.
  > ESLint: [no-useless-escape](https://eslint.org/docs/rules/no-useless-escape)  

  ```js
  // ✗ bad
  "\'";
  '\"';
  '\#';
  '\e';
  `\"`;
  `\"${foo}\"`;
  `\#{foo}`;
  /\!/;
  /\@/;
  ```
  
  ```js
  // ✓ good
  '"';
  '\'';
  '\x12';
  '\u00a9';
  'xs\u2111';
  `\``;
  `\${${foo}}`;
  `$\{${foo}}`;
  /\\/g;
  /\t/g;
  /\w\$\*\^\./;
  ```

<a name="default-case"></a><a name="4.27"></a>
- [4.27](#default-case). 암묵적으로 default case 를 생략하지 않는다.
  
  default case 를 사용하지 않을 경우엔 명시적으로 no default 주석을 추가하면 된다.  
  
  > ESLint: [default-case](https://eslint.org/docs/rules/default-case)  

  ```js
  // ✗ bad
  switch (a) {
    case 1:
      /* code */
      break;
  }
  ```
  
  ```js
  // ✓ good
  switch (a) {
    case 1:
      /* code */
      break;

    // no default
  }

  switch (a) {
    case 1:
      /* code */
      break;

    // No Default
  }
  ```

<a name="no-cond-assign"></a><a name="4.28"></a>
- [4.28](#no-cond-assign). 조건부 안에서 할당할 때 추가로 괄호로 묶는다.
  > ESLint: [no-cond-assign](https://eslint.org/docs/rules/no-cond-assign)  

  ```js
  // ✗ bad
  while (m = text.match(expr)) {
    // ...
  }
  ```
  
  ```js
  // ✓ good
  while ((m = text.match(expr))) {
    // ...
  }
  ```

<a name="no-fallthrough"></a><a name="4.29"></a>
- [4.29](#no-fallthrough). case 문이 비어있지 않으면 암묵적으로 종료문을 생략하지 않는다.
  
  break, return, throw 가 종료문에 해당하며, 의도적으로 종료하지 않는 경우 주석으로 fall through 를 명시한다.  
  
  > ESLint: [no-fallthrough](https://eslint.org/docs/rules/no-fallthrough)  

  ```js
  // ✗ bad
  switch (foo) {
    case 1:
      doSomething();

    case 2:
      doSomething();
  }
  ```
  
  ```js
  // ✓ good
  switch (foo) {
    case 1:
      doSomething();
      break;

    case 2:
      doSomething();
  }

  function bar (foo) {
    switch (foo) {
      case 1:
        doSomething();
        return;

      case 2:
        doSomething();
    }
  }

  switch (foo) {
    case 1:
      doSomething();
      throw new Error('Boo!');

    case 2:
      doSomething();
  }

  switch (foo) {
    case 1:
    case 2:
      doSomething();
  }

  switch (foo) {
    case 1:
      doSomething();
      // falls through

    case 2:
      doSomething();
  }
  ```

<a name="no-unmodified-loop-condition"></a><a name="4.30"></a>
- [4.30](#no-unmodified-loop-condition). 무한 반복되는 반복문을 사용하지 않는다.
  > ESLint: [no-unmodified-loop-condition](https://eslint.org/docs/rules/no-unmodified-loop-condition)  

  ```js
  // ✗ bad
  while (node) {
    doSomething(node);
  }
  node = other;

  for (var j = 0; j < items.length; ++i) {
    doSomething(items[j]);
  }

  while (node !== root) {
    doSomething(node);
  }
  ```
  
  ```js
  // ✓ good
  while (node) {
    doSomething(node);
    node = node.parent;
  }

  for (var j = 0; j < items.length; ++j) {
    doSomething(items[j]);
  }

  // OK, node 값이 변경됨
  while (node !== root) {
    doSomething(node);
    node = node.parent;
  }

  // doSomething() 안에서 obj.foo 변경 가능
  while (obj.foo) {
    doSomething(obj);
  }

  // check() 함수값이 달라질 수 있음
  while (check(obj)) {
    doSomething(obj);
  }
  ```

<a name="eqeqeq"></a><a name="4.31"></a>
- [4.31](#eqeqeq). &#x3D;&#x3D;와 !&#x3D; 대신 &#x3D;&#x3D;&#x3D;와 !&#x3D;&#x3D;를 사용한다.
  > ESLint: [eqeqeq](https://eslint.org/docs/rules/eqeqeq)  

  ```js
  // ✗ bad
  a == b;
  foo == true;
  bananas != 1;
  value == undefined;
  typeof foo == 'undefined';
  'hello' != 'world';
  0 == 0;
  true == true;
  foo == null;
  ```
  
  ```js
  // ✓ good
  a === b;
  foo === true;
  bananas !== 1;
  value === undefined;
  typeof foo === 'undefined';
  'hello' !== 'world';
  0 === 0;
  true === true;
  foo === null;
  ```

<a name="no-self-compare"></a><a name="4.32"></a>
- [4.32](#no-self-compare). 변수를 자기 자신과 비교하지 않는다.
  > ESLint: [no-self-compare](https://eslint.org/docs/rules/no-self-compare)  

  ```js
  // ✗ bad
  var x = 10;
  if (x === x) {
    // do something...
  }
  ```

<a name="yoda"></a><a name="4.33"></a>
- [4.33](#yoda). 비교문은 변수를 좌변에 둔다.
  > ESLint: [yoda](https://eslint.org/docs/rules/yoda)  

  ```js
  // ✗ bad
  if ('red' === color) {
    // ...
  }

  if (true === flag) {
    // ...
  }

  if (5 > count) {
    // ...
  }

  if (-1 < str.indexOf(substr)) {
    // ...
  }

  if (0 <= x && x < 1) {
    // ...
  }
  ```
  
  ```js
  // ✓ good
  if (value === 'red') {
    // ...
  }

  if (5 & value) {
    // ...
  }
  ```

<a name="handle-callback-err"></a><a name="4.34"></a>
- [4.34](#handle-callback-err). 에러 객체는 항상 처리한다.
  
  파라미터 이름이 err, error 처럼 에러로 추정되는 경우, 반드시 해당 에러를 처리해야 한다.  
에러로 추정하는 패턴은 ^[\S]*(e|E)rr(or)?$ 이다.  
  
  > ESLint: [handle-callback-err](https://eslint.org/docs/rules/handle-callback-err)  

  ```js
  // ✗ bad
  function loadData (err, data) {
    doSomething();
  }

  function loadData (error, data) {
    doSomething();
  }

  function loadData (parseErr, data) {
    doSomething();
  }

  function loadData (parseError, data) {
    doSomething();
  }
  ```
  
  ```js
  // ✓ good
  function loadData (err, data) {
    if (err) {
      console.log(err.stack);
    }
    doSomething();
  }

  function loadData (error, data) {
    if (error) {
      console.log(error.stack);
    }
    doSomething();
  }

  function loadData (parseErr, data) {
    if (parseErr) {
      console.log(parseErr.stack);
    }
    doSomething();
  }

  function loadData (parseError, data) {
    if (parseError) {
      console.log(parseError.stack);
    }
    doSomething();
  }
  ```

<a name="no-throw-literal"></a><a name="4.35"></a>
- [4.35](#no-throw-literal). 반드시 throw는 Error 객체를 사용한다.
  > ESLint: [no-throw-literal](https://eslint.org/docs/rules/no-throw-literal)  

  ```js
  // ✗ bad
  throw 'error';

  throw 0;

  throw undefined;

  throw null;

  var err = new Error();
  throw 'an ' + err;
  ```
  
  ```js
  // ✓ good
  throw new Error();

  throw new Error('error');

  var e = new Error('error');
  throw e;

  try {
    throw new Error('error');
  } catch (e) {
    throw e;
  }
  ```

<a name="no-eval"></a><a name="4.36"></a>
- [4.36](#no-eval). eval()을 사용하지 않는다.
  > ESLint: [no-eval](https://eslint.org/docs/rules/no-eval)  

  ```js
  // ✗ bad
  var obj = {x: 'foo'};
  var key = 'x';
  var value = eval('obj.' + key);

  (0, eval)('var a = 0');

  var foo = eval;
  foo('var a = 0');

  // This `this` is the global object.
  this.eval('var a = 0');
  ```
  
  ```js
  // ✓ good
  var obj = {x: 'foo'};
  var key = 'x';
  var value = obj[key];
  ```

<a name="no-implied-eval"></a><a name="4.37"></a>
- [4.37](#no-implied-eval). 문자열을 코드로 실행하지 않는다.
  > ESLint: [no-implied-eval](https://eslint.org/docs/rules/no-implied-eval)  

  ```js
  // ✗ bad
  setTimeout("alert('Hi!');", 100);

  setInterval("alert('Hi!');", 100);

  execScript("alert('Hi!')");

  window.setTimeout('count = 5', 10);

  window.setInterval('foo = bar', 10);
  ```
  
  ```js
  // ✓ good
  setTimeout(function () {
    alert('Hi!');
  }, 100);

  setInterval(function () {
    alert('Hi!');
  }, 100);
  ```

<a name="no-labels"></a><a name="4.38"></a>
- [4.38](#no-labels). 라벨문을 사용하지 않는다.
  > ESLint: [no-labels](https://eslint.org/docs/rules/no-labels)  

  ```js
  // ✗ bad
  label:
  while (true) {
    // ...
  }

  label:
  while (true) {
    break label;
  }

  label:
  while (true) {
    continue label;
  }

  label:
  switch (a) {
    case 0:
      break label;
  }

  label: {
    break label;
  }

  label:
  if (a) {
    break label;
  }
  ```
  
  ```js
  // ✓ good
  while (condition) {
    break;
  }

  while (condition) {
    continue;
  }
  ```

<a name="no-magic-numbers"></a><a name="4.39"></a>
- [4.39](#no-magic-numbers). 의미를 바로 알 수 없는 상수의 사용을 지양한다.
  
  에러가 아닌 **경고**로 표시하는 규칙이다. 따라서 수정할 필요가 없다고 판단되는 경우 무시할 수 있다.  
많이 사용되는 네 가지 숫자 -1, 0, 1, 2 는 아래 이유 때문에 허용한다.
  - -1: Array.prototype.indexOf 등 많이 사용되는 몇몇 함수의 경우 없는 값을 표현하기 위해 -1을 반환
  - 0: 배열이 비어있는지 확인하거나 반복문에서 사용하는 변수의 초기값 등에서 많이 사용
  - 1: 반복문의 종료 조건이나 최소값 등의 표현에서 많이 사용
  - 2: 값을 절반으로 나누는 표현 등 계산식에서 많이 사용  
  
  > ESLint: [no-magic-numbers](https://eslint.org/docs/rules/no-magic-numbers)  
  > 이유: 의미를 바로 알 수 없는 상수를 사용하면 코드 가독성이 떨어지고, 수정이 어려워진다.  
  ```js
  // ✗ bad
  var dutyFreePrice = 100;
  var finalPrice = dutyFreePrice + (dutyFreePrice * 0.25);

  var data = ['foo', 'bar', 'baz', 'rem'];
  var dataLast = data[3];
  ```
  
  ```js
  // ✓ good
  var TAX = 0.25;

  var dutyFreePrice = 100;
  var finalPrice = dutyFreePrice + (dutyFreePrice * TAX);

  function isEmptyArray (arr) {
    return arr.length === 0;
  }
  ```

<a name="no-unused-expressions"></a><a name="4.40"></a>
- [4.40](#no-unused-expressions). 의미 없는 표현식을 사용하지 않는다.
  > ESLint: [no-unused-expressions](https://eslint.org/docs/rules/no-unused-expressions)  

  ```js
  // ✗ bad
  0;

  if (0) 0;

  { 0; }

  a() && function anIncompleteIIFE () {};

  a && b;

  foo || 0;

  a ? b : 0;

  a ? b : c();
  ```
  
  ```js
  // ✓ good
  a && b();

  var a = foo || 0;

  a ? b() : c();
  ```

<a name="no-with"></a><a name="4.41"></a>
- [4.41](#no-with). with문을 사용하지 않는다.
  > ESLint: [no-with](https://eslint.org/docs/rules/no-with)  

  ```js
  // ✗ bad
  with (point) {
    r = Math.sqrt(x * x + y * y); // is r a member of point?
  }
  ```


**[⬆ 처음으로](#table-of-contents)**

---

