# TypeScript Style Guide

이 문서는 TypeScript 로 작성된 코드에 권장되는 코딩 스타일을 안내합니다.

이 문서의 규칙은 TypeScript 에 적용되는 규칙만 추가로 안내합니다. 이 문서를 읽기 전에 아래 문서를 먼저 확인하시는 것을 권장합니다.
- [ES3](https://github.daumkakao.com/webtech/styleguide/tree/master/es3)
- [ES2015+](https://github.daumkakao.com/webtech/styleguide/tree/master/es2015)
- [JSDoc 주석](https://github.daumkakao.com/webtech/styleguide/tree/master/comment)


이 문서의 규칙들은 ESLint 에서 제시한 다음 기준으로 구분됩니다.  

- Variables: 변수 선언 및 정의와 관련된 규칙들
- Stylistic Issues: 가독성을 높이고 협업자 모두가 동일한 스타일을 유지하기 위한 규칙들 
- Possible Errors: 문법 또는 논리적 문제를 방지하는 규칙들  
- Best Practices: 문제를 피하는 더 좋은 방법을 제안하는 규칙들

각각의 분류 안에서는 Airbnb JavaScript StyleGuide 에서 제시한 분류 기준으로 모아서, 다음 순서대로 나열합니다.

1. Types
1. Type casting & coercion
1. Variables
1. Naming conventions
1. Whitespace
1. Blocks
1. Commas
1. Semicolons
1. Objects
1. Properties
1. Functions
1. Arrow Functions
1. Strings
1. Arrays
1. RegExp
1. Classes & Constructors
1. Iterators & Generators
1. Control statements
1. Comparison Operators & Equality
1. Destructuring
1. Modules
1. Errors
1. Comments
1. Etc

---



## Table of Contents

- **1. Variables**
  - [1.1. 사용되지 않는 플래그는 쓰지 않는다.](#@typescript-eslint/no-unused-vars)
  - [1.2. 변수가 정의되기 전에 사용하지 않는다.](#@typescript-eslint/no-use-before-define)
- **2. Stylistic Issues**
  - [2.1. 변수나 함수, 프로퍼티 이름 사용 시 카멜케이스(camelcase)를 사용한다.](#@typescript-eslint/camelcase)
  - [2.2. 들여쓰기는 space 2문자(2칸 들여쓰기)를 사용한다.](#@typescript-eslint/indent)
  - [2.3. type annotation 뒤에 공백을 추가한다.](#@typescript-eslint/type-annotation-spacing)
  - [2.4. interface, type 선언시 멤버 구분자로 세미콜론(;)을 사용한다.](#@typescript-eslint/member-delimiter-style)
  - [2.5. overload 한 멤버들은 연속되게 적는다.](#@typescript-eslint/adjacent-overload-signatures)
  - [2.6. 클래스명은 파스칼 표기법을 사용한다.](#@typescript-eslint/class-name-casing)
  - [2.7. 멤버 선언을 필드, 생성자, 메서드 순으로 한다.](#@typescript-eslint/member-ordering)
- **3. Possible Errors**
  - [3.1. 인터페이스의 생성자 사용과 클래스에서의 constructor 대신 new 사용을 하지 않는다. ](#@typescript-eslint/no-misused-new)
- **4. Best Practices**
  - [4.1. Type assertion 사용시, &lt;Type&gt; 대신 as Type 을 사용한다.](#@typescript-eslint/consistent-type-assertions)
  - [4.2. 숫자, 문자열, 불리언으로 초기화된 변수 또는 매개변수의 타입을 불필요하게 명시하지 않는다.](#@typescript-eslint/no-inferrable-types)
  - [4.3. 후위 연산자 &#x27;!&#x27;를 사용한  non-null-assertions 을 허용하지 않는다.](#@typescript-eslint/no-non-null-assertion)
  - [4.4. 예외 경우를 제외하고 제네릭 배열 생성자를 사용하지 않는다.](#@typescript-eslint/no-array-constructor)
  - [4.5. 클래스 속성과 메서드에 접근 제한자를 명시한다.](#@typescript-eslint/explicit-member-accessibility)
  - [4.6. 클래스 생성자에서 인자 프로퍼티를 사용하지 않는다.](#@typescript-eslint/no-parameter-properties)
  - [4.7. 사용자 정의 TypeScript 모듈 및 네임 스페이스 사용을 허용하지 않는다.](#@typescript-eslint/no-namespace)
  - [4.8. import 문을 사용할 때를 제외하고 require 문을 사용하지 않는다.](#@typescript-eslint/no-var-requires)
  - [4.9. 사용자 정의 TypeScript 모듈을 선언할 때 module 대신 namespace 카워드를 사용한다.](#@typescript-eslint/prefer-namespace-keyword)
  - [4.10. ///(triple slash directives) 대신 ES6 import 선언을 사용한다.](#@typescript-eslint/triple-slash-reference)
  - [4.11. 빈 인터페이스의 선언을 금지한다.](#@typescript-eslint/no-empty-interface)
  - [4.12. 의미를 바로 알 수 없는 상수의 사용을 지양한다.](#@typescript-eslint/no-magic-numbers)

---

## 1. Variables

<a name="@typescript-eslint/no-unused-vars"></a><a name="1.1"></a>
- [1.1](#@typescript-eslint/no-unused-vars). 사용되지 않는 플래그는 쓰지 않는다.
  > typescript-eslint: [@typescript-eslint/no-unused-vars](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-unused-vars.md)  

  ```ts
  // ✗ bad
  interface Foo {}
  ```
  
  ```ts
  // ✓ good
  interface Foo {}
  
  class Bar implements Foo {}
  new Bar();
  ```

<a name="@typescript-eslint/no-use-before-define"></a><a name="1.2"></a>
- [1.2](#@typescript-eslint/no-use-before-define). 변수가 정의되기 전에 사용하지 않는다.
  > typescript-eslint: [@typescript-eslint/no-use-before-define](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-use-before-define.md)  

  ```ts
  // ✗ bad
  alert(a);
  let a = 10;
  
  f();
  function f() {}
  
  function g() {
    return b;
  }
  let b = 1;
  
  {
    alert(c);
    let c = 1;
  }
  
  let myVar: StringOrNumber;
  type StringOrNumber = string | number;
  ```
  
  ```ts
  // ✓ good
  let a;
  a = 10;
  alert(a);
  
  function f() {}
  f(1);
  
  let b = 1;
  function g() {
    return b;
  }
  
  {
    let C;
    c++;
  }
  
  type StringOrNumber = string | number;
  let myVar: StringOrNumber;
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 2. Stylistic Issues

<a name="@typescript-eslint/camelcase"></a><a name="2.1"></a>
- [2.1](#@typescript-eslint/camelcase). 변수나 함수, 프로퍼티 이름 사용 시 카멜케이스(camelcase)를 사용한다.
  > typescript-eslint: [@typescript-eslint/camelcase](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/camelcase.md)  

  ```ts
  // ✗ bad
  import {no_camelcased} from 'external-module';
  
  const my_favorite_color = '#112C85';
  
  function do_something() {
    // ...
  }
  
  obj.do_something = function() {
    // ...
  };
  
  function foo({no_camelcased}) {
    // ...
  }
  
  function foo({isCamelcased: no_camelcased}) {
    // ...
  }
  
  function foo({no_camelcased = 'default value'}) {
    // ...
  }
  
  const obj = {
    my_pref: 1,
  };
  
  const {category_id = 1} = query;
  
  const {foo: no_camelcased} = bar;
  
  const {foo: bar_baz = 1} = quz;
  ```
  
  ```ts
  // ✓ good
  import {no_camelcased as camelCased} from 'external-module';
  
  const myFavoriteColor = '#112C85';
  
  const foo = bar.baz_boom;
  
  obj.do_something();
  
  function foo({isCamelCased}) {
    // ...
  }
  
  function foo({isCamelCased: isAlsoCamelCased}) {
    // ...
  }
  
  function foo({isCamelCased = 'default value'}) {
    // ...
  }
  
  const {categoryId = 1} = query;
  
  const {foo: isCamelCased} = bar;
  
  const {foo: isCamelCased = 1} = quz;
  ```

<a name="@typescript-eslint/indent"></a><a name="2.2"></a>
- [2.2](#@typescript-eslint/indent). 들여쓰기는 space 2문자(2칸 들여쓰기)를 사용한다.
  > typescript-eslint: [@typescript-eslint/indent](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/indent.md)  

  ```ts
  // ✗ bad
  switch (a) {
    case 'a':
          break;
      case 'b':
          break;
  }
  
  (function () {
      function foo (x) {
          return x + 1;
      }
  })();
  
  foo
      .bar
      .baz();
  
  foo(bar,
      baz,
      qux
  );
  
  const foo = [
      bar,
      baz,
      qux
  ];
  
  if (foo) {
      doSomething();
      doSomethingElse();
  }
  ```
  
  ```ts
  // ✓ good
  switch (a) {
    case 'a':
      break;
    case 'b':
      break;
  }
  
  (function () {
    function foo (x) {
      return x + 1;
    }
  })();
  
  foo
    .bar
    .baz();
  
  foo(bar,
    baz,
    qux
  );
  
  const foo = [
    bar,
    baz,
    qux
  ];
  
  if (foo) {
    doSomething();
    doSomethingElse();
  }
  ```

<a name="@typescript-eslint/type-annotation-spacing"></a><a name="2.3"></a>
- [2.3](#@typescript-eslint/type-annotation-spacing). type annotation 뒤에 공백을 추가한다.
  
  콜론(:)의 경우 뒤에만 공백을 추가하고, 화살표 함수의 경우 화살표 앞뒤에 공백을 추가한다.  
  
  > typescript-eslint: [@typescript-eslint/type-annotation-spacing](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/type-annotation-spacing.md)  

  ```ts
  // ✗ bad
  let foo:string = 'bar';
  let foo :string = 'bar';
  let foo : string = 'bar';
  
  function foo():string {}
  function foo() :string {}
  function foo() : string {}
  
  class Foo {
    private name:string;
  }
  
  class Foo {
    private name :string;
  }
  
  class Foo {
    private name : string;
  }
  
  type Foo = ()=> {};
  ```
  
  ```ts
  // ✓ good
  let foo = 'bar';
  
  function foo(): string {}
  
  class Foo {
    private name: string;
  }
  
  type Foo = () => {};
  ```

<a name="@typescript-eslint/member-delimiter-style"></a><a name="2.4"></a>
- [2.4](#@typescript-eslint/member-delimiter-style). interface, type 선언시 멤버 구분자로 세미콜론(;)을 사용한다.
  
  마지막 멤버에도 구분자를 추가해야 하며, 한 줄 선언인 경우 구분자를 생략한다.  
  
  > typescript-eslint: [@typescript-eslint/member-delimiter-style](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/member-delimiter-style.md)  

  ```ts
  // ✗ bad
  // 구분자가 생략됨
  interface Foo {
    name: string
    greet(): string
  }
  
  // 구분자로 세미콜론을 사용하지 않음
  interface Bar {
    name: string,
    greet(): string,
  }
  
  // 마지막 멤버에 세미콜론이 생략됨
  interface Baz {
    name: string;
    greet(): string
  }
  
  // 한 줄 멤버에 구분자를 사용함
  interface Foo { name: string; }
  ```
  
  ```ts
  // ✓ good
  interface Foo {
    name: string;
    greet(): string;
  }
  
  interface Foo { name: string }
  
  type Bar = {
    name: string;
    greet(): string;
  }
  
  type Bar = { name: string }
  ```

<a name="@typescript-eslint/adjacent-overload-signatures"></a><a name="2.5"></a>
- [2.5](#@typescript-eslint/adjacent-overload-signatures). overload 한 멤버들은 연속되게 적는다.
  > typescript-eslint: [@typescript-eslint/adjacent-overload-signatures](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/adjacent-overload-signatures.md)  

  ```ts
  // ✗ bad
  declare namespace Foo {
    export function foo(s: string): void;
    export function foo(n: number): void;
    export function bar(): void;
    export function foo(sn: string | number): void;
  }
  
  export function foo(s: string): void;
  export function foo(n: number): void;
  export function bar(): void;
  export function foo(sn: string | number): void;
  ```
  
  ```ts
  // ✓ good
  declare namespace Foo {
    export function foo(s: string): void;
    export function foo(n: number): void;
    export function foo(sn: string | number): void;
    export function bar(): void;
  }
  
  export function bar(): void;
  export function foo(s: string): void;
  export function foo(n: number): void;
  export function foo(sn: string | number): void;
  ```

<a name="@typescript-eslint/class-name-casing"></a><a name="2.6"></a>
- [2.6](#@typescript-eslint/class-name-casing). 클래스명은 파스칼 표기법을 사용한다.
  > typescript-eslint: [@typescript-eslint/class-name-casing](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/class-name-casing.md)  

  ```ts
  // ✗ bad
  class invalidClassName {
  
  }
  
  class Another_Invalid_Class_Name {
  
  }
  
  const bar = class invalidName {};
  
  interface someInterface {}
  ```
  
  ```ts
  // ✓ good
  class ValidClassName {
  
  }
  
  export default class {
  
  }
  
  const foo = class {};
  
  interface SomeInterface {}
  ```

<a name="@typescript-eslint/member-ordering"></a><a name="2.7"></a>
- [2.7](#@typescript-eslint/member-ordering). 멤버 선언을 필드, 생성자, 메서드 순으로 한다.
  > typescript-eslint: [@typescript-eslint/member-ordering](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/member-ordering.md)  

  ```ts
  // ✗ bad
  interface Foo {
    // 필드
    B: string;
  
    // 생성자
    new();
  
    // 메서드
    A(): void;
  }
  
  interface Foo {
    // 생성자
    new();
  
    // 메서드
    A(): void;
  
    // 필드
    B: string;
  }
  ```
  
  ```ts
  // ✓ good
  interface Foo {
    // 필드
    B: string;
  
    // 생성자
    new();
  
    // 메서드
    A(): void;
  }
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 3. Possible Errors

<a name="@typescript-eslint/no-misused-new"></a><a name="3.1"></a>
- [3.1](#@typescript-eslint/no-misused-new). 인터페이스의 생성자 사용과 클래스에서의 constructor 대신 new 사용을 하지 않는다. 
  > typescript-eslint: [@typescript-eslint/no-misused-new](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-misused-new.md)  

  ```ts
  // ✗ bad
  class C {
    public new(): C;
  }
  
  interface I {
    new (): I;
    constructor(): void;
  }
  ```
  
  ```ts
  // ✓ good
  class C {
    public constructor() {}
  }
  interface I {
    new (): C;
  }
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 4. Best Practices

<a name="@typescript-eslint/consistent-type-assertions"></a><a name="4.1"></a>
- [4.1](#@typescript-eslint/consistent-type-assertions). Type assertion 사용시, &lt;Type&gt; 대신 as Type 을 사용한다.
  > typescript-eslint: [@typescript-eslint/consistent-type-assertions](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/consistent-type-assertions.md)  
  > 이유: JSX 문법과 유사하여 파싱에 문제를 일으킬 수 있다.  
  ```ts
  // ✗ bad
  const foo = <Foo>bar;
  ```
  
  ```ts
  // ✓ good
  const foo = bar as Foo;
  ```

<a name="@typescript-eslint/no-inferrable-types"></a><a name="4.2"></a>
- [4.2](#@typescript-eslint/no-inferrable-types). 숫자, 문자열, 불리언으로 초기화된 변수 또는 매개변수의 타입을 불필요하게 명시하지 않는다.
  > typescript-eslint: [@typescript-eslint/no-inferrable-types](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-inferrable-types.md)  

  ```ts
  // ✗ bad
  const foo: number = 5;
  const bar: boolean = true;
  const baz: string = 'str';
  
  class Foo {
    private prop: number = 5;
  }
  
  function fn(a: number = 5, b: boolean = true) {
  }
  ```
  
  ```ts
  // ✓ good
  const foo = 5;
  const bar = true;
  const baz = 'str';
  
  class Foo {
    private prop = 5;
  }
  
  function fn(a = 5, b = true) {
  }
  
  function fn(a: number, b: boolean, c: string) {
  }
  ```

<a name="@typescript-eslint/no-non-null-assertion"></a><a name="4.3"></a>
- [4.3](#@typescript-eslint/no-non-null-assertion). 후위 연산자 &#x27;!&#x27;를 사용한  non-null-assertions 을 허용하지 않는다.
  > typescript-eslint: [@typescript-eslint/no-non-null-assertion](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-non-null-assertion.md)  

  ```ts
  // ✗ bad
  interface Foo {
    bar?: string;
  }
  
  const foo: Foo = getFoo();
  const includesBaz: boolean = foo.bar!.includes('baz');
  ```
  
  ```ts
  // ✓ good
  interface Foo {
    bar?: string;
  }
  
  const foo: Foo = getFoo();
  const includesBaz: boolean = foo.bar && foo.bar.includes('baz');
  ```

<a name="@typescript-eslint/no-array-constructor"></a><a name="4.4"></a>
- [4.4](#@typescript-eslint/no-array-constructor). 예외 경우를 제외하고 제네릭 배열 생성자를 사용하지 않는다.
  
  단, 특정 크기를 가진 sparse array를 생성하거나, 배열의 타입 선언을 위해 사용하는 경우는 허용된다.  
  
  > typescript-eslint: [@typescript-eslint/no-array-constructor](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-array-constructor.md)  
  > 이유: 제네릭 배열 선언 시 단일 인수의 잘못된 사용, 배열 전역을 다시 정의하는 문제가 있을 수 있기 때문에 리터럴 생성자를 사용하는 것을 지향한다.  
  ```ts
  // ✗ bad
  Array(0, 1, 2)
  new Array(0, 1, 2)
  ```
  
  ```ts
  // ✓ good
  Array<number>(0, 1, 2)
  new Array<Foo>(x, y, z)
  
  Array(500)
  new Array(someOtherArray.length)
  ```

<a name="@typescript-eslint/explicit-member-accessibility"></a><a name="4.5"></a>
- [4.5](#@typescript-eslint/explicit-member-accessibility). 클래스 속성과 메서드에 접근 제한자를 명시한다.
  > typescript-eslint: [@typescript-eslint/explicit-member-accessibility](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/explicit-member-accessibility.md)  

  ```ts
  // ✗ bad
  class Animal {
    name: string
    getName (): string {}
  }
  ```
  
  ```ts
  // ✓ good
  class Animal {
    private name: string
    public getName (): string {}
  }
  ```

<a name="@typescript-eslint/no-parameter-properties"></a><a name="4.6"></a>
- [4.6](#@typescript-eslint/no-parameter-properties). 클래스 생성자에서 인자 프로퍼티를 사용하지 않는다.
  > typescript-eslint: [@typescript-eslint/no-parameter-properties](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-parameter-properties.md)  

  ```ts
  // ✗ bad
  class Foo {
    public constructor(readonly name: string) {}
  }
  
  class Foo {
    public constructor(private name: string) {}
  }
  
  class Foo {
    public constructor(protected name: string) {}
  }
  
  class Foo {
    public constructor(public name: string) {}
  }
  
  class Foo {
    public constructor(private readonly name: string) {}
  }
  
  class Foo {
    public constructor(protected readonly name: string) {}
  }
  
  class Foo {
    public constructor(public readonly name: string) {}
  }
  ```
  
  ```ts
  // ✓ good
  @typescript-eslint/no-unused-vars,
    @typescript-eslint/explicit-member-accessibility */
  class Foo {
    public constructor( name: string) {}
  }
    @typescript-eslint/no-unused-vars,
    @typescript-eslint/explicit-member-accessibility */
  ```

<a name="@typescript-eslint/no-namespace"></a><a name="4.7"></a>
- [4.7](#@typescript-eslint/no-namespace). 사용자 정의 TypeScript 모듈 및 네임 스페이스 사용을 허용하지 않는다.
  > typescript-eslint: [@typescript-eslint/no-namespace](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-namespace.md)  

  ```ts
  // ✗ bad
  module foo {}
  namespace foo {}
  
  declare module foo {}
  declare namespace foo {}
  ```
  
  ```ts
  // ✓ good
  declare module 'foo' {}
  ```

<a name="@typescript-eslint/no-var-requires"></a><a name="4.8"></a>
- [4.8](#@typescript-eslint/no-var-requires). import 문을 사용할 때를 제외하고 require 문을 사용하지 않는다.
  > typescript-eslint: [@typescript-eslint/no-var-requires](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-var-requires.md)  

  ```ts
  // ✗ bad
  const foo = require('foo');
  let foo = require('foo');
  ```
  
  ```ts
  // ✓ good
  import foo = require('foo');
  require('foo');
  ```

<a name="@typescript-eslint/prefer-namespace-keyword"></a><a name="4.9"></a>
- [4.9](#@typescript-eslint/prefer-namespace-keyword). 사용자 정의 TypeScript 모듈을 선언할 때 module 대신 namespace 카워드를 사용한다.
  > typescript-eslint: [@typescript-eslint/prefer-namespace-keyword](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/prefer-namespace-keyword.md)  

  ```ts
  // ✗ bad
  module TutorialPoint {
    export function add(x, y) {
      console.log(x + y);
    }
  }
  ```
  
  ```ts
  // ✓ good
  namespace TutorialPoint {
    export function add(x, y) { console.log(x + y);}
  }
  ```

<a name="@typescript-eslint/triple-slash-reference"></a><a name="4.10"></a>
- [4.10](#@typescript-eslint/triple-slash-reference). ///(triple slash directives) 대신 ES6 import 선언을 사용한다.
  > typescript-eslint: [@typescript-eslint/triple-slash-reference](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/triple-slash-reference.md)  

  ```ts
  // ✗ bad
  /// <reference path='Animal'>
  ```
  
  ```ts
  // ✓ good
  import Animal from 'Animal'
  ```

<a name="@typescript-eslint/no-empty-interface"></a><a name="4.11"></a>
- [4.11](#@typescript-eslint/no-empty-interface). 빈 인터페이스의 선언을 금지한다.
  > typescript-eslint: [@typescript-eslint/no-empty-interface](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-empty-interface.md)  

  ```ts
  // ✗ bad
  interface Foo { }
  
  interface Bar extends Foo { }
  
  interface Baz extends { }
  ```
  
  ```ts
  // ✓ good
  interface Foo {
    name: string;
  }
  
  interface Bar {
    age: number;
  }
  
  interface Baz extends Foo, Bar { }
  ```

<a name="@typescript-eslint/no-magic-numbers"></a><a name="4.12"></a>
- [4.12](#@typescript-eslint/no-magic-numbers). 의미를 바로 알 수 없는 상수의 사용을 지양한다.
  
  에러가 아닌 **경고**로 표시하는 규칙이다. 따라서 수정할 필요가 없다고 판단되는 경우 무시할 수 있다.  
많이 사용되는 네 가지 숫자 -1, 0, 1, 2 는 아래 이유 때문에 허용한다.
  - -1: Array.prototype.indexOf 등 많이 사용되는 몇몇 함수의 경우 없는 값을 표현하기 위해 -1을 반환
  - 0: 배열이 비어있는지 확인하거나 반복문에서 사용하는 변수의 초기값 등에서 많이 사용
  - 1: 반복문의 종료 조건이나 최소값 등의 표현에서 많이 사용
  - 2: 값을 절반으로 나누는 표현 등 계산식에서 많이 사용  
literal type, readonly class property, enum에서 사용하는 상수는 허용된다.  
  
  
  > typescript-eslint: [@typescript-eslint/no-magic-numbers](https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-magic-numbers.md)  
  > 이유: 의미를 바로 알 수 없는 상수를 사용하면 코드 가독성이 떨어지고, 수정이 어려워진다.  
  ```ts
  // ✗ bad
  const dutyFreePrice = 100;
  const finalPrice = dutyFreePrice + (dutyFreePrice * 0.25);
  
  const data = ['foo', 'bar', 'baz', 'rem'];
  const dataLast = data[3];
  ```
  
  ```ts
  // ✓ good
  const TAX = 0.25;
  
  const dutyFreePrice = 100;
  const finalPrice = dutyFreePrice + (dutyFreePrice * TAX);
  
  function isEmptyArray (arr) {
    return arr.length === 0;
  }
  
  // literal type
  type SmallPrimes = 2 | 3 | 5 | 7 | 11;
  
  // readonly class property
  class Foo {
    readonly A = 1;
    readonly B = 2;
    public static readonly C = 1;
    static readonly D = 1;
  }
  
  // enum
  enum foo = {
    SECOND = 1000,
  }
  ```


**[⬆ 처음으로](#table-of-contents)**

---

