# ES2015+ Style Guide

이 문서는 ECMAScript 2015+ 로 작성된 코드에 권장되는 코딩 스타일을 안내합니다.

이 문서의 규칙은 ES2015 이상에 적용되는 규칙만 추가로 안내합니다. 이 문서를 읽기 전에 아래 문서를 먼저 확인하시는 것을 권장합니다. 
- [ES3](../es3)
- [JSDoc 주석](../comment)

참고한 사이트
- [Airbnb JavaScript StyleGuide](https://github.com/airbnb/javascript)
- [ESLint 홈페이지](https://eslint.org/)

이 문서의 규칙들은 ESLint 에서 제시한 다음 기준으로 구분됩니다.  

- Variables: 변수 선언 및 정의와 관련된 규칙들
- Stylistic Issues: 가독성을 높이고 협업자 모두가 동일한 스타일을 유지하기 위한 규칙들 
- Possible Errors: 문법 또는 논리적 문제를 방지하는 규칙들  
- Best Practices: 문제를 피하는 더 좋은 방법을 제안하는 규칙들

각각의 분류 안에서는 Airbnb JavaScript StyleGuide 에서 제시한 분류 기준으로 모아서, 다음 순서대로 나열합니다.

1. Types
1. Type casting & coercion
1. Variables
1. Naming conventions
1. Whitespace
1. Blocks
1. Commas
1. Semicolons
1. Objects
1. Properties
1. Functions
1. Arrow Functions
1. Strings
1. Arrays
1. RegExp
1. Classes & Constructors
1. Iterators & Generators
1. Control statements
1. Comparison Operators & Equality
1. Destructuring
1. Modules
1. Errors
1. Comments
1. Etc

---

## Table of Contents

- **1. Variables**
  - [1.1. const에 재할당하지 않는다.](#no-const-assign)
  - [1.2. 중첩된 scope에서 같은 이름을 사용해서 바깥 scope의 이름을 가리지 않는다.](#no-shadow)
  - [1.3. var 키워드는 사용하지 않는다.](#no-var)
  - [1.4. 값이 변하지 않는 변수는 const, 값이 변하는 변수는 let을 사용하여 선언한다.](#prefer-const)
- **2. Stylistic Issues**
  - [2.1. 객체/배열인 경우 trailing comma를 사용한다.](#comma-dangle)
  - [2.2. 메서드, 클래스 리터럴의 닫는 중괄호 뒤에 세미콜론을 생략한다.](#no-extra-semi)
  - [2.3. 객체 또는 배열에서 복수의 프로퍼티에 접근할 때는 비구조화를 사용한다.](#prefer-destructuring)
  - [2.4. 화살표 함수 블록에 중괄호를 사용한다.](#arrow-body-style)
  - [2.5. 화살표 함수 사용 시 인수가 하나인 경우 괄호를 생략한다.](#arrow-parens)
  - [2.6. 화살표 함수의 화살표 앞뒤로 공백을 추가한다.](#arrow-spacing)
  - [2.7. 암시적 반환을 하는 화살표 함수 몸체의 위치를 화살표 함수에 표시한다.](#implicit-arrow-linebreak)
  - [2.8. 문자열을 결합하는 경우 템플릿 문자열을 사용한다.](#prefer-template)
  - [2.9. 템플릿 문자열 사용 시 중괄호 내부에 공백을 제거한다.](#template-curly-spacing)
  - [2.10. 메서드 문법을 사용한다.](#object-shorthand)
  - [2.11. generator 사용 시 function 과 별표(*) 사이를 붙여 쓰고, 뒤에는 공백을 추가한다.](#generator-star-spacing)
  - [2.12. yield에서 별표(*) 사용 시 별표 뒤에만 공백을 추가한다.](#yield-star-spacing)
- **3. Possible Errors**
  - [3.1. 파생 클래스의 생성자에서 super()을 호출한다.](#constructor-super)
  - [3.2. 선언된 클래스 값에 다른 값을 할당하지 않는다.](#no-class-assign)
  - [3.3. 클래스 멤버끼리 중복된 이름을 사용하지 않는다.](#no-dupe-class-members)
  - [3.4. this/super 사용 전에 생성자에서 super() 메소드를 호출한다.](#no-this-before-super)
  - [3.5. 비어있는 비구조화 패턴은 사용하지 않는다.](#no-empty-pattern)
  - [3.6. Symbol 생성자를 사용하지 않는다.](#no-new-symbol)
- **4. Best Practices**
  - [4.1. switch문의 case/default에서 선언문은 중괄호로 감싼다.](#no-case-declarations)
  - [4.2. 불필요한 computed key 를 사용하지 않는다.](#no-useless-computed-key)
  - [4.3. await을 반환하지 않는다.](#no-return-await)
  - [4.4. 가변 인자를 다룰 때 arguments 대신 rest 연산자를 사용한다.](#prefer-rest-params)
  - [4.5. argument를 전달하는 경우 apply를 사용하지 말고 전개 연산자를 사용한다.](#prefer-spread)
  - [4.6. 화살표 함수 구문과 비교 연산자를 혼동되지 않도록 사용한다.](#no-confusing-arrow)
  - [4.7. 함수 표현식 대신 화살표 함수를 사용한다.](#prefer-arrow-callback)
  - [4.8. 모든 import 구문을 파일의 최상위에 위치시킨다.](#import/first)
  - [4.9. 상수 참조만 export 한다.](#import/no-mutable-exports)
  - [4.10. 모듈 당 하나의 import 구문을 사용한다.](#no-duplicate-imports)
  - [4.11. 동일 이름으로 재할당하지 않는다.](#no-useless-rename)

---

## 1. Variables

<a name="no-const-assign"></a><a name="1.1"></a>
- [1.1](#no-const-assign). const에 재할당하지 않는다.
  > ESLint: [no-const-assign](https://eslint.org/docs/rules/no-const-assign)  

  ```js
  // ✗ bad
  const a = 0;
  a = 1;

  const b = 0;
  b += 1;
  ```
  
  ```js
  // ✓ good
  const a = 0;
  console.log(a);

  for (const a in [1, 2, 3]) {
    console.log(a);
  }
  ```

<a name="no-shadow"></a><a name="1.2"></a>
- [1.2](#no-shadow). 중첩된 scope에서 같은 이름을 사용해서 바깥 scope의 이름을 가리지 않는다.
  > ESLint: [no-shadow](https://eslint.org/docs/rules/no-shadow)  
  > 이유: 의도하지 않은 변수 참조/수정에 따른 버그를 사전에 방지  
  ```js
  // ✗ bad
  const a = 3;
  function b () {
    const a = 10;
  }

  const c = function () {
    const a = 10;
  };

  function d (a) {
    a = 10;
  }
  b(a);

  if (true) {
    const a = 5;
  }
  ```
  
  ```js
  // ✓ good
  const xList = [
    /* ... */
  ];
  const yList = [
    /* ... */
  ];

  for (let xIndex = 0; xIndex <= xList.length; xIndex++) {
    for (let yIndex = 0; yIndex <= yList.length; yIndex++) {
      // 중첩된 scope에서 xIndex와 yIndex 처럼 변수 값을 다르게 해서 실수를 방지
    }
  }
  ```

<a name="no-var"></a><a name="1.3"></a>
- [1.3](#no-var). var 키워드는 사용하지 않는다.
  > ESLint: [no-var](https://eslint.org/docs/rules/no-var)  

  ```js
  // ✗ bad
  var x = 'y';
  var CONFIG = {};
  ```
  
  ```js
  // ✓ good
  const a = 'b';
  const CONTAINER = {};
  ```

<a name="prefer-const"></a><a name="1.4"></a>
- [1.4](#prefer-const). 값이 변하지 않는 변수는 const, 값이 변하는 변수는 let을 사용하여 선언한다.
  > ESLint: [prefer-const](https://eslint.org/docs/rules/prefer-const)  

  ```js
  // ✗ bad
  for (let a of [1, 2, 3]) {
    console.log(a);
  }
  ```
  
  ```js
  // ✓ good
  for (const a of [1, 2, 3]) {
    console.log(a);
  }
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 2. Stylistic Issues

<a name="comma-dangle"></a><a name="2.1"></a>
- [2.1](#comma-dangle). 객체/배열인 경우 trailing comma를 사용한다.
  
  배열의 경우 여러 줄로 표현될 때만 trailing comma를 사용한다.  
  
  > ESLint: [comma-dangle](https://eslint.org/docs/rules/comma-dangle)  

  ```js
  // ✗ bad
  const obj = {
    bar: 'baz',
    qux: 'quux'
  };

  const arr1 = [1, 2, ];
  const arr2 = [1,
    2, ];
  const arr3 = [
    1,
    2
  ];
  ```
  
  ```js
  // ✓ good
  const obj = {
    bar: 'baz',
    qux: 'quux',
  };

  const arr1 = [1, 2];
  const arr2 = [1,
    2];
  const arr3 = [
    1,
    2,
  ];
  ```

<a name="no-extra-semi"></a><a name="2.2"></a>
- [2.2](#no-extra-semi). 메서드, 클래스 리터럴의 닫는 중괄호 뒤에 세미콜론을 생략한다.
  > ESLint: [no-extra-semi](https://eslint.org/docs/rules/no-extra-semi)  

  ```js
  // ✗ bad
  class Foo {
    constructor () {
      this.x = 42;
    }
    method () {
      return this.x;
    };
  };
  ```
  
  ```js
  // ✓ good
  class Foo {
    constructor () {
      this.x = 42;
    }
    method () {
      return this.x;
    }
  }
  ```

<a name="prefer-destructuring"></a><a name="2.3"></a>
- [2.3](#prefer-destructuring). 객체 또는 배열에서 복수의 프로퍼티에 접근할 때는 비구조화를 사용한다.
  > ESLint: [prefer-destructuring](https://eslint.org/docs/rules/prefer-destructuring)  

  ```js
  // ✗ bad
  function getCrewName (crew) {
    const nickName = crew.nickName;
    const realName = crew.realName;

    return `${nickName} ${realName}`;
  }

  const foo = array[0];
  const bar = obj.bar;
  ```
  
  ```js
  // ✓ good
  function getCrewName ({nickName, realName}) {
    return `${nickName} ${realName}`;
  }

  const [foo] = array;
  const {bar} = obj;
  ```

<a name="arrow-body-style"></a><a name="2.4"></a>
- [2.4](#arrow-body-style). 화살표 함수 블록에 중괄호를 사용한다.
  
  간결한 함수 바디(concise body)를 사용하는 경우에는 생략이 가능하다.  
  
  > ESLint: [arrow-body-style](https://eslint.org/docs/rules/arrow-body-style)  

  ```js
  // ✗ bad
  const fn1 = () => {
    return 0;
  };
  const fn2 = () => {
    return {
      bar: {
        foo: 1,
        bar: 2,
      },
    };
  };
  ```
  
  ```js
  // ✓ good
  const fn1 = () => 0;
  const fn2 = () => ({
    bar: {
      foo: 1,
      bar: 2,
    },
  });
  const fn3 = (retv, name) => {
    retv[name] = true;
    return retv;
  };
  const fn4 = () => { bar(); };
  const fn5 = () => {};
  const fn6 = () => { /* do nothing */ };
  const fn7 = () => {
    // do nothing.
  };
  const fn8 = () => ({bar: 0});
  ```

<a name="arrow-parens"></a><a name="2.5"></a>
- [2.5](#arrow-parens). 화살표 함수 사용 시 인수가 하나인 경우 괄호를 생략한다.
  > ESLint: [arrow-parens](https://eslint.org/docs/rules/arrow-parens)  

  ```js
  // ✗ bad
  const foo = (a) => {};
  ```
  
  ```js
  // ✓ good
  const foo = a => {};
  const bar = (a, b) => {};
  ```

<a name="arrow-spacing"></a><a name="2.6"></a>
- [2.6](#arrow-spacing). 화살표 함수의 화살표 앞뒤로 공백을 추가한다.
  > ESLint: [arrow-spacing](https://eslint.org/docs/rules/arrow-spacing)  

  ```js
  // ✗ bad
  ()=> {};
  () =>{};
  a=> {};
  a =>{};
  a =>a;
  a=> a;
  ()=> { '\n'; };
  () =>{ '\n'; };
  ```
  
  ```js
  // ✓ good
  () => {};
  a => {};
  a => a;
  () => { '\n'; };
  ```

<a name="implicit-arrow-linebreak"></a><a name="2.7"></a>
- [2.7](#implicit-arrow-linebreak). 암시적 반환을 하는 화살표 함수 몸체의 위치를 화살표 함수에 표시한다.
  
  함수 선언과 몸체 사이에 개행이 있을 때는 함수 선언에 몸체를 표시한다  
  
  > ESLint: [implicit-arrow-linebreak](https://eslint.org/docs/rules/implicit-arrow-linebreak)  

  ```js
  // ✗ bad
  foo =>
    bar;

  foo =>
    (bar);

  foo =>
    bar =>
      baz;

  foo =>
    (
      bar()
    );
  ```
  
  ```js
  // ✓ good
  foo => bar;

  foo => (bar);

  foo => bar => baz;

  foo => (
    bar()
  );

  foo => bar();

  foo => bar();
  ```

<a name="prefer-template"></a><a name="2.8"></a>
- [2.8](#prefer-template). 문자열을 결합하는 경우 템플릿 문자열을 사용한다.
  > ESLint: [prefer-template](https://eslint.org/docs/rules/prefer-template)  

  ```js
  // ✗ bad
  const str1 = 'Hello, ' + name + '!';
  const str2 = 'Time: ' + (12 * 60 * 60 * 1000);
  ```
  
  ```js
  // ✓ good
  const str1 = 'Hello World!';
  const str2 = `Hello, ${name}!`;
  const str3 = `Time: ${12 * 60 * 60 * 1000}`;

  const str4 = 'Hello, ' + 'World!';
  ```

<a name="template-curly-spacing"></a><a name="2.9"></a>
- [2.9](#template-curly-spacing). 템플릿 문자열 사용 시 중괄호 내부에 공백을 제거한다.
  > ESLint: [template-curly-spacing](https://eslint.org/docs/rules/template-curly-spacing)  

  ```js
  // ✗ bad
  `hello, ${ people.name}!`;
  `hello, ${people.name }!`;
  `hello, ${ people.name }!`;
  ```
  
  ```js
  // ✓ good
  `hello, ${people.name}!`;

  `hello, ${
    people.name
  }!`;
  ```

<a name="object-shorthand"></a><a name="2.10"></a>
- [2.10](#object-shorthand). 메서드 문법을 사용한다.
  > ESLint: [object-shorthand](https://eslint.org/docs/rules/object-shorthand)  

  ```js
  // ✗ bad
  const foo = {
    w: function () {},
    x: function* () {},
    [y]: function () {},
    z: z,
  };
  ```
  
  ```js
  // ✓ good
  const foo = {
    x: y => y,
  };
  ```
  
  ```js
  // ✓ best
  const foo = {
    w () {},
    * x () {},
    [y] () {},
    z,
  };
  ```
  

<a name="generator-star-spacing"></a><a name="2.11"></a>
- [2.11](#generator-star-spacing). generator 사용 시 function 과 별표(*) 사이를 붙여 쓰고, 뒤에는 공백을 추가한다.
  > ESLint: [generator-star-spacing](https://eslint.org/docs/rules/generator-star-spacing)  
  > 이유: 별표(\*)가 연산자로 사용된다기보다는 function\* 자체가 하나의 의미를 가지기 때문이다.  
  ```js
  // ✗ bad
  function * generator () {}
  function *generator () {}
  function*generator () {}

  const func1 = function * () {};
  const func2 = function *() {};
  const func3 = function*() {};

  const func4 = {*generator () {}};
  ```
  
  ```js
  // ✓ good
  function* generator () {}

  const func1 = function* () {};

  const func2 = {* generator () {}};
  ```

<a name="yield-star-spacing"></a><a name="2.12"></a>
- [2.12](#yield-star-spacing). yield에서 별표(*) 사용 시 별표 뒤에만 공백을 추가한다.
  > ESLint: [yield-star-spacing](https://eslint.org/docs/rules/yield-star-spacing)  
  > 이유: 별표(\*)가 연산자로 사용된다기보다는 yield\* 자체가 하나의 의미를 가지기 때문이다.  
  ```js
  // ✗ bad
  function* generator () {
    yield * other();
  }
  function* generator () {
    yield *other();
  }
  function* generator () {
    yield*other();
  }
  ```
  
  ```js
  // ✓ good
  function* generator () {
    yield* other();
  }
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 3. Possible Errors

<a name="constructor-super"></a><a name="3.1"></a>
- [3.1](#constructor-super). 파생 클래스의 생성자에서 super()을 호출한다.
  > ESLint: [constructor-super](https://eslint.org/docs/rules/constructor-super)  

  ```js
  // ✗ bad
  class A {}

  class B extends A {
    constructor () {}
  }

  class C extends null {
    constructor () {
      super();
    }
  }

  class D extends null {
    constructor () {}
  }
  ```
  
  ```js
  // ✓ good
  class A {
    constructor () {}
  }

  class B extends A {
    constructor () {
      super();
    }
  }
  ```

<a name="no-class-assign"></a><a name="3.2"></a>
- [3.2](#no-class-assign). 선언된 클래스 값에 다른 값을 할당하지 않는다.
  > ESLint: [no-class-assign](https://eslint.org/docs/rules/no-class-assign)  

  ```js
  // ✗ bad
  class A { }
  A = 0;

  B = 0;
  class B { }

  class C {
    C () {
      A = 0;
    }
  }
  ```
  
  ```js
  // ✓ good
  let A = class A { };
  A = 0; // A 는 변수

  let B = class {
    b () {
      B = 0; // B 는 변수
    }
  };
  ```

<a name="no-dupe-class-members"></a><a name="3.3"></a>
- [3.3](#no-dupe-class-members). 클래스 멤버끼리 중복된 이름을 사용하지 않는다.
  > ESLint: [no-dupe-class-members](https://eslint.org/docs/rules/no-dupe-class-members)  

  ```js
  // ✗ bad
  class Foo1 {
    bar () { }
    bar () { }
  }

  class Foo2 {
    bar () { }
    get bar () { }
  }

  class Foo3 {
    static bar () { }
    static bar () { }
  }
  ```
  
  ```js
  // ✓ good
  class Foo1 {
    bar () { }
    qux () { }
  }

  class Foo2 {
    get bar () { }
    set bar (value) { }
  }

  class Foo3 {
    static bar () { }
    bar () { }
  }
  ```

<a name="no-this-before-super"></a><a name="3.4"></a>
- [3.4](#no-this-before-super). this/super 사용 전에 생성자에서 super() 메소드를 호출한다.
  > ESLint: [no-this-before-super](https://eslint.org/docs/rules/no-this-before-super)  

  ```js
  // ✗ bad
  class Bad extends Parent {
    constructor() {
      this.a = 0;
      super();
    }
  }

  class Bad2 extends Parent {
    constructor() {
      this.foo();
      super();
    }
  }

  class Bad3 extends Parent {
    constructor() {
      super.foo();
      super();
    }
  }

  class Bad4 extends Parent {
    constructor() {
      super(this.foo());
    }
  }
  ```
  
  ```js
  // ✓ good
  class Good {
    constructor () {
      this.a = 0; // extends 하지 않은 클래스의 this 사용
    }
  }

  class Good2 extends Parent {
    constructor () {
      super();
      this.a = 0; // super() 호출 뒤에 this 사용
    }
  }

  class Good3 extends Parent {
    foo () {
      this.a = 0; // 생성자가 아닌 함수에서 this 사용
    }
  }
  ```

<a name="no-empty-pattern"></a><a name="3.5"></a>
- [3.5](#no-empty-pattern). 비어있는 비구조화 패턴은 사용하지 않는다.
  > ESLint: [no-empty-pattern](https://eslint.org/docs/rules/no-empty-pattern)  

  ```js
  // ✗ bad
  const {} = foo;
  const [] = foo;
  const {
    a: {},
  } = foo;

  const {
    a: [],
  } = foo;

  function bad1 ({}) {}

  function bad2 ([]) {}

  function bad3 ({a: {}}) {}

  function bad4 ({a: []}) {}
  ```
  
  ```js
  // ✓ good
  const {a = {}} = foo;
  const {b = []} = foo;

  function good1 ({c = {}}) {}

  function good2 ({d = []}) {}
  ```

<a name="no-new-symbol"></a><a name="3.6"></a>
- [3.6](#no-new-symbol). Symbol 생성자를 사용하지 않는다.
  > ESLint: [no-new-symbol](https://eslint.org/docs/rules/no-new-symbol)  

  ```js
  // ✗ bad
  const foo = new Symbol('foo');
  ```
  
  ```js
  // ✓ good
  const foo = Symbol('foo');

  function bar (Symbol) {
    const baz = new Symbol('baz');
  }
  ```


**[⬆ 처음으로](#table-of-contents)**

---

## 4. Best Practices

<a name="no-case-declarations"></a><a name="4.1"></a>
- [4.1](#no-case-declarations). switch문의 case/default에서 선언문은 중괄호로 감싼다.
  > ESLint: [no-case-declarations](https://eslint.org/docs/rules/no-case-declarations)  

  ```js
  // ✗ bad
  switch (foo) {
    case 1:
      const x = 1;
      break;
    case 2:
      const y = 2;
      break;
    case 3:
      function f () {}
      break;
    default:
      class C {}
  }
  ```
  
  ```js
  // ✓ good
  switch (foo) {
    case 1: {
      const x = 1;
      break;
    }
    case 2: {
      const y = 2;
      break;
    }
    case 3: {
      function f () {}
      break;
    }
    default: {
      class C {}
    }
  }
  ```

<a name="no-useless-computed-key"></a><a name="4.2"></a>
- [4.2](#no-useless-computed-key). 불필요한 computed key 를 사용하지 않는다.
  > ESLint: [no-useless-computed-key](https://eslint.org/docs/rules/no-useless-computed-key)  

  ```js
  // ✗ bad
  const foo1 = {['0']: 0};
  const foo2 = {['0+1,234']: 0};
  const foo3 = {[0]: 0};
  const foo4 = {['x']: 0};
  const foo5 = {['x'] () {}};
  ```
  
  ```js
  // ✓ good
  const foo1 = {a: 0};
  const foo2 = {0: 0};
  const foo3 = {x () {}};
  const foo4 = {a: 0};
  const foo5 = {'0+1,234': 0};
  ```

<a name="no-return-await"></a><a name="4.3"></a>
- [4.3](#no-return-await). await을 반환하지 않는다.
  > ESLint: [no-return-await](https://eslint.org/docs/rules/no-return-await)  

  ```js
  // ✗ bad
  async function foo () {
    return await bar();
  }
  ```
  
  ```js
  // ✓ good
  async function foo () {
    return bar();
  }

  async function foo () {
    await bar();
  }

  async function foo () {
    const x = await bar();
    return x;
  }

  async function foo () {
    try {
      return await bar();
    } catch (error) {}
  }
  ```

<a name="prefer-rest-params"></a><a name="4.4"></a>
- [4.4](#prefer-rest-params). 가변 인자를 다룰 때 arguments 대신 rest 연산자를 사용한다.
  > ESLint: [prefer-rest-params](https://eslint.org/docs/rules/prefer-rest-params)  

  ```js
  // ✗ bad
  function foo () {
    console.log(arguments);
  }

  function foo (action) {
    const args = Array.prototype.slice.call(arguments, 1);
    action.apply(null, args);
  }

  function foo (action) {
    const args = [].slice.call(arguments, 1);
    action.apply(null, args);
  }
  ```
  
  ```js
  // ✓ good
  function foo (...args) {
    console.log(args);
  }

  function foo (action, ...args) {
    action(...args);
  }
  ```

<a name="prefer-spread"></a><a name="4.5"></a>
- [4.5](#prefer-spread). argument를 전달하는 경우 apply를 사용하지 말고 전개 연산자를 사용한다.
  > ESLint: [prefer-spread](https://eslint.org/docs/rules/prefer-spread)  

  ```js
  // ✗ bad
  foo.apply(undefined, args);
  foo.apply(null, args);
  obj.foo.apply(obj, args);
  ```
  
  ```js
  // ✓ good
  foo(...args);
  obj.foo(...args);

  foo.apply(obj, args);
  obj.foo.apply(null, args);
  obj.foo.apply(otherObj, args);

  foo.apply(undefined, [1, 2, 3]);
  foo.apply(null, [1, 2, 3]);
  obj.foo.apply(obj, [1, 2, 3]);
  ```

<a name="no-confusing-arrow"></a><a name="4.6"></a>
- [4.6](#no-confusing-arrow). 화살표 함수 구문과 비교 연산자를 혼동되지 않도록 사용한다.
  
  괄호를 통해서 함수 구문과 연산자를 구분 짓는다.  
  
  > ESLint: [no-confusing-arrow](https://eslint.org/docs/rules/no-confusing-arrow)  

  ```js
  // ✗ bad
  const foo = a => bar ? 2 : 3;
  ```
  
  ```js
  // ✓ good
  const foo = a => (bar ? 2 : 3);
  ```

<a name="prefer-arrow-callback"></a><a name="4.7"></a>
- [4.7](#prefer-arrow-callback). 함수 표현식 대신 화살표 함수를 사용한다.
  > ESLint: [prefer-arrow-callback](https://eslint.org/docs/rules/prefer-arrow-callback)  

  ```js
  // ✗ bad
  foo(a => a); // ERROR
  // prefer: foo(a => a)

  foo(() => this.a); // ERROR
  // prefer: foo(() => this.a)
  ```
  
  ```js
  // ✓ good
  foo(a => a); // OK

  foo(function* () { yield; }); // OK

  const foo = function foo (a) { return a; }; // OK

  foo(function () { return this.a; }); // OK

  foo(function bar (n) { return n && n + bar(n - 1); }); // OK
  ```

<a name="import/first"></a><a name="4.8"></a>
- [4.8](#import/first). 모든 import 구문을 파일의 최상위에 위치시킨다.
  > ESLint: [import/first](https://eslint.org/docs/rules/import/first)  

  ```js
  // ✗ bad
  import foo from 'foo';
  foo.init();
  
  import bar from 'bar';
  ```
  
  ```js
  // ✓ good
  import foo from 'foo';
  import bar from 'bar';
  
  foo.init();
  ```

<a name="import/no-mutable-exports"></a><a name="4.9"></a>
- [4.9](#import/no-mutable-exports). 상수 참조만 export 한다.
  > ESLint: [import/no-mutable-exports](https://eslint.org/docs/rules/import/no-mutable-exports)  

  ```js
  // ✗ bad
  let foo = 3;
  export {foo} ;
  ```
  
  ```js
  // ✓ good
  const foo = 3;
  export {foo};
  ```

<a name="no-duplicate-imports"></a><a name="4.10"></a>
- [4.10](#no-duplicate-imports). 모듈 당 하나의 import 구문을 사용한다.
  > ESLint: [no-duplicate-imports](https://eslint.org/docs/rules/no-duplicate-imports)  

  ```js
  // ✗ bad
  import {merge} from 'module';
  import something from 'another-module';
  import {find} from 'module';
  ```
  
  ```js
  // ✓ good
  import {merge, find} from 'module';
  import something from 'another-module';
  ```

<a name="no-useless-rename"></a><a name="4.11"></a>
- [4.11](#no-useless-rename). 동일 이름으로 재할당하지 않는다.
  > ESLint: [no-useless-rename](https://eslint.org/docs/rules/no-useless-rename)  

  ```js
  // ✗ bad
  import {foo as foo} from 'bar';
  export {foo as foo};
  let {foo: foo} = bar;
  ```
  
  ```js
  // ✓ good
  import {foo} from 'bar';
  export {foo};
  let {foo} = bar;
  ```


**[⬆ 처음으로](#table-of-contents)**

---

