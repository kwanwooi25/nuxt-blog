const fs = require('fs');
const path = require('path');
const Handlebars = require('handlebars');
const {compile} = Handlebars;

const {LINT_CATEGORY, AIRBNB_CATEGORY, RULE_DEF_TYPE} = require('./constants');

const RULE_PATH = 'rules';
const TEMPLATE_PATH = 'templates';
const DOC_FILENAME = 'README.md';
const LINT_FILENAME = '.eslintrc.js';

const RULE_INDEX_FILENAME = 'index.js';
const RULE_EXAM_BAD_FILENAME = 'bad';
const RULE_EXAM_GOOD_FILENAME = 'good';
const RULE_EXAM_BEST_FILENAME = 'best';

const UNBOXING_MAGIC_STR = '%%';

const isIndexFile = filename => filename === RULE_INDEX_FILENAME;
const isJavaScriptFile = filename => /.js$/.test(filename);

const customHelpers = {
  moveTOC: (number, adder) => {
    const [int, ...rest] = number
      .toString()
      .split('.');

    return [Number(int) + Number(adder), ...rest].join('.');
  },
  sliceTSRuleName: ruleName => ruleName.split('/').slice(-1, ruleName.length),
};

const init = () => {
  Object
    .entries(customHelpers)
    .forEach(([name, helper]) => Handlebars.registerHelper(name, helper));
};
init();

const loadRulesByFolder = rulesDir => {
  const fileList = [];
  const dirTraversal = path => {
    const isDir = fs.statSync(path).isDirectory();

    if (isDir) {
      const children = fs.readdirSync(path);
      const isRuleDir = children.some(isIndexFile);
      if (isRuleDir) {
        fileList.push(path.split(`${rulesDir}/`).join(''));
      } else {
        children.forEach(filename => dirTraversal(`${path}/${filename}`));
      }
    }
  };
  dirTraversal(rulesDir);

  const readExamFile = (ruleDir, filename) => {
    const filepath = path.resolve(__dirname, '../../', rulesDir, ruleDir, filename);
    if (!fs.existsSync(filepath)) {
      return null;
    }

    return fs.readFileSync(filepath).toString().split('\n').filter(line => !line.startsWith('/* eslint')).join('\n').trim();
  };

  const rules = fileList.map(ruleDir => {
    const filepath = path.resolve(__dirname, '../../', rulesDir, ruleDir, RULE_INDEX_FILENAME);

    // cache 를 비워주어야 watch 모드에서 파일이 reload 된다.
    delete require.cache[filepath];

    const rule = require(filepath);
    rule.rule = ruleDir;
    rule.rulename = ruleDir.split('jsdoc/').join('');

    const fileExtension = filepath.includes('typescript') ? '.ts' : '.js';

    const bad = readExamFile(ruleDir, `${RULE_EXAM_BAD_FILENAME}${fileExtension}`);
    const good = readExamFile(ruleDir, `${RULE_EXAM_GOOD_FILENAME}${fileExtension}`);
    const best = readExamFile(ruleDir, `${RULE_EXAM_BEST_FILENAME}${fileExtension}`);

    if (bad) {
      rule.bad = bad;
    }

    if (good) {
      rule.good = good;
    }

    if (best) {
      rule.best = best;
    }

    return rule;
  });

  return rules;
};

const loadRulesByFile = rulesDir => {
  const ruleFiles = fs.readdirSync(rulesDir).filter(isJavaScriptFile);

  return ruleFiles.map(filename => {
    const filepath = path.resolve(__dirname, '../../', rulesDir, filename);

    // cache 를 비워주어야 watch 모드에서 파일이 reload 된다.
    delete require.cache[filepath];

    return require(filepath);
  });
};

// *.js 파일로부터 규칙 정보를 담은 객체들의 배열을 만드는 함수
const loadRules = (rulesDir, ruleDefType) => {
  switch (ruleDefType) {
    case RULE_DEF_TYPE.SEPARATED_BY_FILE:
      return loadRulesByFile(rulesDir);

    case RULE_DEF_TYPE.SEPARATED_BY_FOLDER:
      return loadRulesByFolder(rulesDir);

    default:
      throw new Error('규칙 정의 타입이 필요합니다.');
  }
};

// 예제 코드 추출
const getExampleFnBody = fn => {
  if (!fn) {
    return null;
  }

  if (typeof fn === 'string') {
    return fn.trim().replace(/\n/g, '\n  ');
  }

  const reg = /^\(\)\s*=>\s*{[\s]*\n([\s\S]*)}$/g;
  return reg.exec(fn.toString())[1].trim();
};

// constants.js 파일에 선언한 순서대로 정렬하기 위해 참고하는 표를 생성
const airbnbSortTable = Object.values(AIRBNB_CATEGORY).reduce(
  (prev, name, order) => {
    prev[name] = order;
    return prev;
  },
  {}
);

const ruleNameSort = (r1, r2) => {
  if (r1.rule < r2.rule) {
    return -1;
  } else if (r1.rule > r2.rule) {
    return 1;
  } else {
    return 0;
  }
};

const airbnbSort = (r1, r2) => {
  const airbnbDiff = airbnbSortTable[r1.airbnbCategory] - airbnbSortTable[r2.airbnbCategory];

  if (airbnbDiff !== 0) {
    return airbnbDiff;
  }

  // airbnb 기준, 같은 범주 안에 있다면 알파벳 순으로 정렬한다.
  return ruleNameSort(r1, r2);
};

// 규칙들을 lint 카테고리, airbnb 카테고리 별로 구분짓고 정렬,
const createRules = (targetDir, ruleDefType) => {
  const ruleList = loadRules(`${targetDir}/${RULE_PATH}`, ruleDefType);

  const categoryMap = Object.values(LINT_CATEGORY).reduce((prev, name) => {
    prev[name] = [];
    return prev;
  }, {});

  ruleList.forEach(rule => {
    const {lintCategory} = rule;
    categoryMap[lintCategory].push(rule);
  });

  const categories = [];
  let order = 0;
  for (const [category, list] of Object.entries(categoryMap)) {
    if (list.length === 0) {
      continue;
    }

    categories.push({
      number: order + 1,
      category,
      rules: list.sort(airbnbSort).map((rule, idx) => ({
        ...rule,
        title: rule.title.replace(/__/g, '\\_\\_'),
        number: `${order + 1}.${idx + 1}`,
        bad: getExampleFnBody(rule.bad),
        good: getExampleFnBody(rule.good),
        best: getExampleFnBody(rule.best),
      })),
    });

    order += 1;
  }

  return categories;
};

// 정리된 규칙들 객체로부터 eslint 규칙만 추출
const createESLintRule = rules => rules.reduce((result, {rule, options, disableRule = null}) => {
  if (/process\.env/g.exec(options)) {
    // 동작할 때 환경변수에 따라 다르게 동작해야 하는 경우 규칙이 문자열이 아니라 코드로 들어가야 함
    result[rule] = `${UNBOXING_MAGIC_STR}${options}${UNBOXING_MAGIC_STR}`;
  } else {
    result[rule] = options;
  }

  if (disableRule) { // 무시해야 할 규칙 추가
    result[disableRule.name] = disableRule.option;
  }
  return result;
}, {});

// 실제 eslintrc 파일에 작성될 객체 생성
const createESLintConfig = categories => categories.reduce(
  (prev, {rules}) => ({...prev, ...createESLintRule(rules)}),
  {}
);

// 탬풀랏 파일을 읽어서 handlebars 템플릿으로 변환 후 반환
const getTemplate = (targetDir, name) => {
  let filePath = path.join(targetDir, TEMPLATE_PATH, name);
  if (!fs.existsSync(filePath)) {
    filePath = path.join(__dirname, TEMPLATE_PATH, name);
  }
  const fileBuffer = fs.readFileSync(filePath);
  return compile(fileBuffer.toString());
};

// 문서 생성
const writeDocument = (targetDir, rules) => {
  const headerTemplate = getTemplate(targetDir, 'header.md');
  const tocTemplate = getTemplate(targetDir, 'toc.md');
  const rulesTemplate = getTemplate(targetDir, 'rules.md');
  const footerTemplate = getTemplate(targetDir, 'footer.md');

  const headerStr = headerTemplate();
  const tocStr = tocTemplate({categories: rules});
  const rulesStr = rulesTemplate({categories: rules});
  const footerStr = footerTemplate();

  fs.writeFileSync(`${targetDir}/${DOC_FILENAME}`, `${headerStr}\n${tocStr}\n${rulesStr}\n${footerStr}`);
};

// eslintrc 파일 생성
const writeLintrc = (targetDir, rules) => {
  const lintTemplate = getTemplate(targetDir, '.eslintrc.template');
  const eslintRules = createESLintConfig(rules);
  const unboxingRegexp = new RegExp(`"${UNBOXING_MAGIC_STR}(.+?)${UNBOXING_MAGIC_STR}"`, 'g');
  const eslintRulesStr = JSON.stringify(eslintRules, null, '  ').replace(unboxingRegexp, '$1');

  const lint = lintTemplate({eslintRulesStr});
  fs.writeFileSync(`${targetDir}/${LINT_FILENAME}`, lint);
};

const build = ({
  targetDir,
  ruleDefType = RULE_DEF_TYPE.SEPARATED_BY_FILE,
}) => {
  console.log(`=== start build! targetDir: ${targetDir}, now: ${Date.now()}`);

  const rules = createRules(targetDir, ruleDefType);

  writeDocument(targetDir, rules);
  writeLintrc(targetDir, rules);
};

module.exports = {
  build,
  RULE_PATH,
  TEMPLATE_PATH,
};
